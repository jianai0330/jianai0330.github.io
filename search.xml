<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PPA_notes</title>
    <url>/2019/11/03/ppa/</url>
    <content><![CDATA[<h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><a id="more"></a>
<h3 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h3><ol>
<li>wihle loop</li>
<li>for-each</li>
<li><h4 id="searching"><a href="#searching" class="headerlink" title="searching:"></a>searching:</h4>  loop condition: <em>index &lt; files.size() &amp;&amp; !found</em></li>
<li>不要用input == “bye”比较两个string,一定要用只能用<p>input.equals(“bye”)</p></li>
<li>Iterator与iterator():<br>   iterator()是collection有的一个method,return一个Iterator类的object,这个object可以用这几个Iterator类里的method:<strong>hasNext,next,remove</strong><br>   格式:<code>Iterator&lt;ElementType&gt; it = myCollection.iterator()</code></li>
<li>Index vs Iterator:<strong>remove</strong>的时候用iterator,</li>
<li>anonymous objects: ?啥玩意儿,不管了</li>
</ol>
<h2 id="week7-Chapter6"><a href="#week7-Chapter6" class="headerlink" title="week7 Chapter6"></a>week7 Chapter6</h2><h3 id="研读课本"><a href="#研读课本" class="headerlink" title="研读课本"></a>研读课本</h3><ol>
<li>responsibility-driven design, cohesion, coupling, refactoring</li>
<li>intance method:invoked on an <strong>intance</strong> of a class, 注意class method和instance method不互通不能互相引用</li>
<li>enum(enumerated types):枚举<pre><code> 枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部</code></pre><h3 id="预习PPT-amp-提纲"><a href="#预习PPT-amp-提纲" class="headerlink" title="预习PPT&amp;提纲"></a>预习PPT&amp;提纲</h3><ol>
<li>几个class:random</li>
<li>Set,Map<br>hashSet,hashMap</li>
<li>list,map和set的比较</li>
<li>wrapper classes<br>int 和 Interger</li>
<li>autoboxing and unboxing</li>
<li>static</li>
</ol>
</li>
</ol>
<h2 id="疑惑与计划"><a href="#疑惑与计划" class="headerlink" title="疑惑与计划"></a>疑惑与计划</h2><ol>
<li>auction project的源代码 看 ---11.4早于lse</li>
</ol>
]]></content>
      <categories>
        <category>2019</category>
        <category>KCL</category>
        <category>PPA</category>
      </categories>
  </entry>
  <entry>
    <title>Arduino与Assembly</title>
    <url>/2019/11/01/arduino/</url>
    <content><![CDATA[<h2 id="Lab–汇编语言初识-amp-语法结构"><a href="#Lab–汇编语言初识-amp-语法结构" class="headerlink" title="Lab–汇编语言初识&amp;语法结构"></a>Lab–汇编语言初识&amp;语法结构</h2><a id="more"></a>
<h3 id="第一个程序的理解"><a href="#第一个程序的理解" class="headerlink" title="第一个程序的理解"></a>第一个程序的理解</h3><ol>
<li>.equ SREG,0x3f     :treat the label SREG as 0x3f</li>
<li>.org 0     :the start address</li>
<li>r16--r31,PPRB,PORTC等等在microprocessor’s CPU也就是Atmega328p里</li>
</ol>
<h2 id="lab2-portb-连led"><a href="#lab2-portb-连led" class="headerlink" title="lab2 portb 连led"></a>lab2 portb 连led</h2><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><ol>
<li><h4 id="SREG-status-register"><a href="#SREG-status-register" class="headerlink" title="SREG : status register"></a>SREG : status register</h4></li>
<li><h4 id="Rd-Destination-register-in-the-register-file"><a href="#Rd-Destination-register-in-the-register-file" class="headerlink" title="Rd : Destination register in the register file"></a>Rd : Destination register in the register file</h4></li>
</ol>
<h3 id="arduino里几个概念"><a href="#arduino里几个概念" class="headerlink" title="arduino里几个概念"></a>arduino里几个概念</h3><ol>
<li><h4 id="ATmega是Arduino里面的正方形芯片-microcontroller"><a href="#ATmega是Arduino里面的正方形芯片-microcontroller" class="headerlink" title="ATmega是Arduino里面的正方形芯片,microcontroller"></a>ATmega是Arduino里面的正方形芯片,microcontroller</h4></li>
<li><h4 id="PORTB"><a href="#PORTB" class="headerlink" title="PORTB"></a>PORTB</h4><pre><code> : an 8-bit I/O port with internal pull-up resistors, 位于: 正方形芯片的周边小点(8个:PB7:0)
 它们 连接着the external digital pins</code></pre><table>
<thead>
<tr>
<th>Atemega pin</th>
<th>Nano digital pin</th>
</tr>
</thead>
<tbody><tr>
<td>PB0(在芯片的四周))</td>
<td>D8(在nano的两周,可连接面包板的线)</td>
</tr>
<tr>
<td>PB1</td>
<td>D9</td>
</tr>
<tr>
<td>….</td>
<td>….</td>
</tr>
</tbody></table>
</li>
<li><h4 id="digital-pin"><a href="#digital-pin" class="headerlink" title="digital pin:"></a>digital pin:</h4><pre><code> 位于nona两周: I/O interface(HIGH/LOW)</code></pre></li>
<li>CPU怎么链接PORTB: databus</li>
<li>DDRB跟PORTB,PORTC等等地位相等,都在register里,都是一个一个的寄存器,都是8bit.(each port on Atmega328 has a <strong>Data Direction Register</strong>)</li>
<li>DDRB和PORTB的<strong>关系</strong>:<br>  each bit of in PORTB has a corresponding input or output mode bit in DDRB.<h2 id="Lab3-portc-很好理解-读value"><a href="#Lab3-portc-很好理解-读value" class="headerlink" title="Lab3 portc 很好理解 读value"></a>Lab3 portc 很好理解 读value</h2></li>
</ol>
<h2 id="疑问疑惑"><a href="#疑问疑惑" class="headerlink" title="疑问疑惑"></a>疑问疑惑</h2><h3 id="程序内的语法"><a href="#程序内的语法" class="headerlink" title="程序内的语法:"></a>程序内的语法:</h3><ol>
<li>main,mainloop的意思</li>
<li>rjmp?</li>
<li>brlo <strong>lessthan</strong>? 为什么是lessthan,brlo本身不就是当lower时吗</li>
<li>.org 0,地址0 是跟0x06等等同一地位吗,那我在.equ里面最小的那个地址开始可以吗 --11.3<h3 id="led-on-s"><a href="#led-on-s" class="headerlink" title="led_on.s:"></a>led_on.s:</h3></li>
<li>SREG的作用是什么,设置为0要干什么<h3 id="第三个程序-portc-lab3"><a href="#第三个程序-portc-lab3" class="headerlink" title="第三个程序:portc(lab3)"></a>第三个程序:portc(lab3)</h3></li>
<li>从PINC中读取数据到PORTC,那pinc的数据从何而来?</li>
</ol>
]]></content>
      <categories>
        <category>2019</category>
        <category>KCL</category>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>CS_note</title>
    <url>/2019/10/31/assembly/</url>
    <content><![CDATA[<h1 id="五-performance-measurement-and-analysis"><a href="#五-performance-measurement-and-analysis" class="headerlink" title="五 performance measurement and analysis"></a>五 performance measurement and analysis</h1><a id="more"></a>
<h2 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol>
<li><p>性能equation : 1. CPU time 2. Amdahl’s law</p>
</li>
<li><p>benchmarking: </p>
</li>
<li><p>性能optimisation:<br>RISA&amp;CISC(the two main kinds of ISA design)<br>  <strong>RISC</strong>:reduced instruction set computers   <strong>shorten time by reducing clock cycle</strong></p>
<pre><code> simple instructions,few addressing mode</code></pre><p>  <strong>CISC</strong>:complex isc <strong>reduce the number of instructions per program</strong></p>
<pre><code> complex instructions,many addressing modes</code></pre><p>Branch optimisation: pipeline hazards<br>delayed branching<br>Branch prediction</p>
</li>
<li><p>disk性能: 概念: utilisation U<sub>d</sub>=r<sub>req</sub> / r<sub>srv</sub><br>FCFS: first-come,first served<br>SSTF:shortest seek time first(出现starvation的概念)<br>SCAN:not an acronym<br>C-SCAN:circular SCAN<br>LOOK/C-LOOK</p>
<p>注意比较各种情况下的好坏</p>
<h2 id="课上和课后总结理解难点"><a href="#课上和课后总结理解难点" class="headerlink" title="课上和课后总结理解难点"></a>课上和课后总结理解难点</h2><ol>
<li>flushing the pipeline: conditional branck instructions</li>
<li>clock rate=machine cycles per second</li>
<li></li>
<li></li>
</ol>
</li>
</ol>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>CPU里clock cycle的理解</li>
<li>对于RAM里的两种memory ports: 1. 32-bits for data/address 2. 8-bit for OPCODE,<br> 是说每个横格长都是40bit吗,每一个data前面都有8bit的OPCODE吗,那怎么行得通呢</li>
<li>byte-addressable &amp; word-addressable:<pre><code> byte..:every byte has its own address. (word:every word) </code></pre></li>
</ol>
]]></content>
      <categories>
        <category>2019</category>
        <category>KCL</category>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>CS_note</title>
    <url>/2019/10/31/cs-note/</url>
    <content><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h2><a id="more"></a>
<h1 id="二-Assembly-1"><a href="#二-Assembly-1" class="headerlink" title="二 Assembly 1"></a>二 Assembly 1</h1><ol>
<li><p>CPU<br> registers<br> ALU<br> control unit<br> data bus</p>
</li>
<li><p>memory organisation<br> byte-addressable/word-addressable<br> RAM chips:random access memory  lengthXwidth</p>
</li>
<li><p>I/O</p>
</li>
<li><p>Bus</p>
</li>
<li><p>Clocks<br> clock cycles<br> clock frequency(互为倒数)<br> CPU time</p>
</li>
<li><p>Interrupts</p>
</li>
<li><p>MARIE ISA</p>
<ul>
<li>load: load contents of address x into AC</li>
<li>store: store the contents of AC at address X</li>
<li>add</li>
<li>subt</li>
<li>input/output</li>
<li>halt: 暂停</li>
<li>skipcond: skip next instruction on condition</li>
<li>jump X: load the value of X into PC<br>那么load store jump好像没区别啊?</li>
</ul>
</li>
<li><p>RTL: register transfer language</p>
<h1 id="三-Assembly-2"><a href="#三-Assembly-2" class="headerlink" title="三 Assembly 2"></a>三 Assembly 2</h1></li>
<li><p>fetch-decode-execute cycle<br> PC<br> MAR<br> IR<br> PC<br> MAR<br> MBR</p>
</li>
<li><p>Interrupt processing:PPT上有两个流程图<br>  flags register<br>  maskable<br>  Nonmaskable interrupts</p>
</li>
<li><p>注意PPT里一个简单program在computer里运行的流程图!</p>
</li>
<li><p>Assemblers汇编器的工作流程:PPT!<br>  1st pass: symbol table<br>  2nd pass: the instructions are completed using the value from the <strong>symbol table</strong>.<br>  完成将汇编语言变成机器语言的过程</p>
</li>
<li><p>一个汇编语言程序:main和mainloop是address label.?? main&amp;mainloop的理解</p>
<pre><code>   .equ SREG,0x3F
   .org
   main:   ldi r16,0
           out SREG,r16
   mainloop: rjmp mainloop</code></pre></li>
<li><p>indirect addressing mode时:</p>
</li>
<li><p>JnS:operates by storing the current PC value in the first address of the routine itself,then continue with the instruction following that.    Jump-and-store.<br> JumpI:return from the subroutine.</p>
</li>
<li><p>Clear</p>
</li>
<li><p>if</p>
</li>
<li><p>for/while</p>
</li>
<li><p>Procedure invocation:f()</p>
</li>
<li><p>两个samole constructs!!</p>
<h1 id="四-instruction-set-architectures-pipelines"><a href="#四-instruction-set-architectures-pipelines" class="headerlink" title="四 instruction set architectures/pipelines"></a>四 instruction set architectures/pipelines</h1></li>
<li><p>instruction formats</p>
<ol>
<li>little endian<br>big endian:正常的<br>比较: ///</li>
<li>how the CPU store data(3种)CPU的特殊内部存储结构<br><img src="https://wkretype.bdimg.com/retype/zoom/6a64416127d3240c8447ef13?pn=7&o=jpg_6&md5sum=1830449c7405e4dd2a4f0bb2c1b9644e&sign=df6cd0909c&png=126611-139487&jpg=805027-909057" alt="三种结构"><ol>
<li>stack: instructions and operands都从stack里拿,先进后出<br> stack机器用1/0operand instructions<br> Push X, Pop X<br> Add/Mult</li>
<li>accumulator: operand在memory中</li>
<li>general purpose register: 比accumulator快,instructions更长:<br> Memory-memory:<br> register-memory:至少1个operand在register.<br> load-store:无operand在memory.   </li>
</ol>
</li>
<li>注意0123address machimes 的code(作业中有) </li>
</ol>
</li>
<li><p>instruction types</p>
</li>
<li><p>addressing: where the <strong>operand</strong> is located.(a constant, a register, memory location)<br>  immediate<br>  direct<br>  indirect<br>  indexed:final=base+index</p>
</li>
<li><p>instruction level Pipelining<br> S = NKt<sub>p</sub> / (K+N-1)t<sub>p</sub><br> =K<br> pipeline hazards隐患</p>
</li>
</ol>
<h1 id="五-performance-measurement-and-analysis"><a href="#五-performance-measurement-and-analysis" class="headerlink" title="五 performance measurement and analysis"></a>五 performance measurement and analysis</h1><h2 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol>
<li><p>性能equation : 1. CPU time 2. Amdahl’s law</p>
</li>
<li><p>benchmarking: </p>
</li>
<li><p>性能optimisation:<br>RISA&amp;CISC(the two main kinds of ISA design)指令集类型<br>  <strong>RISC</strong>:reduced instruction set computers   <strong>shorten time by reducing clock cycle</strong></p>
<pre><code> simple instructions,few addressing mode</code></pre><p>  <strong>CISC</strong>:complex isc <strong>reduce the number of instructions per program</strong></p>
<pre><code> complex instructions,many addressing modes</code></pre><p>Branch optimisation: pipeline hazards<br>delayed branching<br>Branch prediction</p>
</li>
<li><p>disk性能: 概念: utilisation U<sub>d</sub>=r<sub>req</sub> / r<sub>srv</sub><br>FCFS: first-come,first served<br>SSTF:shortest seek time first(出现starvation的概念)<br>SCAN:not an acronym<br>C-SCAN:circular SCAN<br>LOOK/C-LOOK</p>
<p>注意比较各种情况下的好坏</p>
<h2 id="课上和课后总结理解难点"><a href="#课上和课后总结理解难点" class="headerlink" title="课上和课后总结理解难点"></a>课上和课后总结理解难点</h2></li>
</ol>
<h1 id="七-二进制①-JoshM"><a href="#七-二进制①-JoshM" class="headerlink" title="七 二进制① JoshM"></a>七 二进制① JoshM</h1><h2 id="PPT提纲-1"><a href="#PPT提纲-1" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol>
<li><p>negative numbers in binary: 几个概念: unsighed binary<br> formats: </p>
<ol>
<li><p>signed magnitude  : MSB(the most significant bit) is a sign bit---0+&amp;1-  源码</p>
<pre><code>      0的源码有两种:00000000&amp;10000000,0的补码只有一个:00000000.</code></pre></li>
<li><p>One’s complement. 反码</p>
</li>
<li><p>Two’s complement  补码(对于正数补码相同)<br>  [X]<sub>补</sub> = X + M<br>  这个M是mod M,模数M根据机器数的位数而定,位数为81则M=2<sup>8</sup><br>对于负数:<br>1.真值:将各位变反,then最低位+1<br>2.源码: 符号位不变,其余各位变反then最低位+1</p>
<pre><code>                        11111111是-1的补码,10000000是-128的补码.0的补码只有一个:00000000.</code></pre></li>
<li><p>注意优缺点!!!(PPT17)</p>
</li>
<li><p>各方式表示的范围</p>
<pre><code>           源码:-127(11111111)\-\-\-+127(01111111)
           补码:-128(10000000)\-\-\-+127(01111111)</code></pre></li>
</ol>
</li>
</ol>
<h2 id="二进制运算法则"><a href="#二进制运算法则" class="headerlink" title="二进制运算法则"></a>二进制运算法则</h2><pre><code>1. 10转2:减权定位
         除基取余(直到商为0):从最下面的余数开始!
   小数10转2:减权定位
            乘基取整:从最上面的余数开始
2. 2转10: 按权相加(小数2转10同)</code></pre><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>Assembly 2 里 JnS </li>
<li>那么load store jump好像没区别啊? ---11.6</li>
<li>对于Assembly1作业中的第3题.醍醐灌顶:<br>A 1-bit address can address two words (0, 1).<br>A 2-bit address can address four words (00, 01, 10, 11).<br>A 3-bit address can address eight words (000, 001, 010, 011, 100, 101, 110, 111).<br>but<img src="https://www.coursehero.com/doc-asset/bg/d6bc39dcf48520faf6897593e05282dad7676ae0/splits/v9.frq.clean/split-1-page-1-html-bg.jpg" alt="答案不一样"></li>
<li>需要加强理解和动手去做的:1. 三种表示二进制数的转化自己去操作. 2. 禁制直接每种情况的转化去运算.   ---11.13</li>
</ol>
]]></content>
      <categories>
        <category>2019</category>
        <category>KCL</category>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>MatLab</title>
    <url>/2019/10/30/matlab/</url>
    <content><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><a id="more"></a>

<h2 id="创建x轴的数组"><a href="#创建x轴的数组" class="headerlink" title="创建x轴的数组"></a>创建x轴的数组</h2><p>s = linspace()<br>与直接[ : : ]</p>
<h2 id="绘制函数图象时"><a href="#绘制函数图象时" class="headerlink" title="绘制函数图象时"></a>绘制函数图象时</h2><p>syms变量–fplot<br>与直接设置x和y对应数组–plot</p>
<h2 id="设置坐标轴范围时"><a href="#设置坐标轴范围时" class="headerlink" title="设置坐标轴范围时"></a>设置坐标轴范围时</h2><p>xlim(xmin ymin)和ylim()<br>与aixs[xmin xmax ymin ymax]</p>
<h2 id="绘制图像的几个函数"><a href="#绘制图像的几个函数" class="headerlink" title="绘制图像的几个函数"></a>绘制图像的几个函数</h2><ul>
<li>plot()</li>
<li>line():画直线型</li>
<li>polar():极坐标下绘曲线</li>
</ul>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="创建矩阵的方法"><a href="#创建矩阵的方法" class="headerlink" title="创建矩阵的方法"></a>创建矩阵的方法</h2><ol>
<li>B=a:h:b;  其中a,b代表一维矩阵（向量）的区间，h为步宽</li>
<li>zeros(行数,列数).ones,rand同.</li>
<li></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>2019</category>
        <category>KCL</category>
        <category>MatLab</category>
      </categories>
      <tags>
        <tag>MatLab</tag>
      </tags>
  </entry>
  <entry>
    <title>CMTE_note</title>
    <url>/2019/10/30/cmte-s-note/</url>
    <content><![CDATA[<h1 id="四-Vector-Algebra"><a href="#四-Vector-Algebra" class="headerlink" title="四 Vector  Algebra"></a>四 Vector  Algebra</h1><h2 id="空间直线-空间平面"><a href="#空间直线-空间平面" class="headerlink" title="空间直线,空间平面"></a>空间直线,空间平面</h2><a id="more"></a>
<h3 id="空间直线几个形式的方程-空间平面的方程"><a href="#空间直线几个形式的方程-空间平面的方程" class="headerlink" title="空间直线几个形式的方程,空间平面的方程."></a>空间直线几个形式的方程,空间平面的方程.</h3><p>Ax +By +Cz + D = 0</p>
<p>其中n = (A, B, C)是平面的法向量，D是将平面平移到坐标原点所需距离（所以D=0时，平面过原点）</p>
<h3 id="空间两直线的距离-点到平面以及到直线的距离-公式"><a href="#空间两直线的距离-点到平面以及到直线的距离-公式" class="headerlink" title="空间两直线的距离,点到平面以及到直线的距离 公式"></a>空间两直线的距离,点到平面以及到直线的距离 公式</h3><p>(联立方程)<br><img src="https://pic002.cnblogs.com/img/zdd/201007/2010071013450338.jpg" alt="点到平面" title="公式"></p>
<h2 id="已知两平面方程求交点坐标"><a href="#已知两平面方程求交点坐标" class="headerlink" title="已知两平面方程求交点坐标"></a>已知两平面方程求交点坐标</h2><h2 id="物理学中的力矩和功"><a href="#物理学中的力矩和功" class="headerlink" title="物理学中的力矩和功"></a>物理学中的力矩和功</h2><p>机械功:work<br>力矩:moment of force<br>     the tendency of a force to make an object <strong>rotate</strong> .<br>两个物理意义不同,符号相同.牛顿-米.<br>力矩<em>t=rXF</em>, 这个r不是功里面那样的在F方向的位移,而是从转轴到施力点的位移矢量.</p>
<h1 id="五-Matrix-Algebra"><a href="#五-Matrix-Algebra" class="headerlink" title="五 Matrix Algebra"></a>五 Matrix Algebra</h1><h2 id="3阶矩阵运算易错的是"><a href="#3阶矩阵运算易错的是" class="headerlink" title="3阶矩阵运算易错的是:"></a>3阶矩阵运算易错的是:</h2><p>第二列的余子式中两列的顺序: 是从左到右 不是从右到左!</p>
<h2 id="课件提纲-amp-概念"><a href="#课件提纲-amp-概念" class="headerlink" title="课件提纲&amp;概念"></a>课件提纲&amp;概念</h2><ol>
<li><p>矩阵---多元方程组</p>
</li>
<li><p>changes of  axes 旋转----结合预科课件: 逆时针顺时针</p>
</li>
<li><h3 id="几个矩阵和概念"><a href="#几个矩阵和概念" class="headerlink" title="几个矩阵和概念"></a>几个矩阵和概念</h3><ul>
<li><p>square m,column/row vector,diagonal m,unit/identity ma,symmetric m,upper-/lower-triangular m,diagonal对角矩阵,scalar数量矩阵(主对角元全相等)</p>
</li>
<li><p>singular:奇异(行列式为0)</p>
</li>
<li><p>trace: 迹sum of <strong>leading diagonal</strong>主对角线(左上右下)</p>
</li>
<li><p>A<sup>T</sup>: 手心手背 转置矩阵</p>
<pre><code>   行列式和转置行列式**相等**</code></pre></li>
<li><p>minor:余子式,cofactor 代数余子式多一个-1的次方</p>
</li>
<li><p>adjoint:伴随矩阵 <strong><em>注意特性和公式</em></strong> 代数余子式组成</p>
</li>
<li><h4 id="inverse-matrix-逆矩阵"><a href="#inverse-matrix-逆矩阵" class="headerlink" title="inverse matrix: 逆矩阵"></a>inverse matrix: 逆矩阵</h4></li>
<li><h4 id="Cramer’s-rule卡姆拉法则"><a href="#Cramer’s-rule卡姆拉法则" class="headerlink" title="Cramer’s rule卡姆拉法则 :"></a>Cramer’s rule卡姆拉法则 :</h4></li>
<li><h4 id="Gaussian-elimination-见矩阵运算板块高斯消元法"><a href="#Gaussian-elimination-见矩阵运算板块高斯消元法" class="headerlink" title="Gaussian elimination: 见矩阵运算板块高斯消元法"></a>Gaussian elimination: 见矩阵运算板块<em>高斯消元法</em></h4></li>
<li><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref<br></h4><pre><code>row echelon form阶梯型矩阵: 下阶梯,leadingentry是1.
rref行简化阶梯形矩阵:在ref基上&lt;p&gt;非零首元所在的列/p&lt;&gt;除了非零首元外，其余元素全为0.每个首项是1.
每个矩阵,ref不唯一,**rref唯一**.</code></pre></li>
<li><p>independent &amp; dependent vectors线性相关无关</p>
<pre><code>linear combination of vectors线性组合(是一个向量而不是关系)
注意根据定义,线性相关是n个向量组成的组,至少其余n-个可以表示一个</code></pre></li>
<li><p>Rank 秩 :最大线性无关的向量的个数  在ref形势下含非0的行数</p>
</li>
<li><p><strong>eigenvalue</strong>特征值</p>
<pre><code> - characteristic polynomial(PPT72页),特征多项式characteristic equation of A特征方程
 - eigenvector特征向量
 - </code></pre></li>
</ul>
</li>
<li><p>注意<strong>矩阵×标量</strong>与行列式×标量的区别: 矩阵式乘每个元素,行列式乘一行.</p>
</li>
<li><h3 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结:"></a>公式总结:</h3><ul>
<li>(AB)<sup>T</sup> = B<sup>T</sup>A<sup>T</sup> &amp; adj(AB) = adj(B)adj(A)</li>
<li>eigenvalue的性质(PPT末尾)</li>
<li><code>AA*=A*A=|A|E</code>  (*伴随矩阵)</li>
<li>A<sup>-1</sup>=(1/|A|)<em>A</em>(可轻易有上一行结合AA<sup>-1</sup>=E推出)</li>
<li>|A*|=|A|<sup>n-1</sup>  (可轻易有上上一行推出)   </li>
</ul>
</li>
<li><h3 id="矩阵运算-化简得基本步骤"><a href="#矩阵运算-化简得基本步骤" class="headerlink" title="矩阵运算,化简得基本步骤"></a>矩阵运算,化简得基本步骤</h3><ul>
<li>Gaussian elimination<em>高斯消元法</em>: <ol>
<li>最左上角变为1,依次用第一行的减-把剩下行的第一个数变0,这是第一遍,</li>
<li>第二遍从第二行开始,把第二行第二列变1,依次用第二行减-使下面的行的第二个数变0,</li>
<li>直到成为上三角.<pre><code>补充:线性方程组的**初等变换**: 
      1. 交换两个方程的位置(就好比与换矩阵的行!理解了)
      2. 一个方程两端同乘不为0的数
      3. 同乘不为0的数后加到另一方程去</code></pre></li>
</ol>
</li>
<li>转化成ref(下阶梯):PPT第58页<pre><code>1. pivot:第一个第一列不为0的行,提到第一行
2. 依次把下面行的第一列第一行变为0
3. 去掉第一列,从新开始找pivot
4. 在此基础上转化成**rref**: 找到非0首元,把其上的全变为0</code></pre></li>
<li>find matrix <strong>rank</strong>:<pre><code>1. 矩阵的ref形式里含有非0行的数量 = 矩阵中independent vector(每一行就是一个vector)</code></pre></li>
<li>eigenvalue: AX = aX<pre><code> - 已知A可求a
 - 已知A和a可求X(eigenvector) </code></pre></li>
<li>矩阵加减:要同规模(与行列式不同,矩阵是每排,行列式不同的那一排(其余的每一排要对应相等))</li>
<li>矩阵乘法:好比说AB,要求是A的列数等于B的行数, 那么得到的矩阵规模是A的行数B的列数<h2 id="二级结论"><a href="#二级结论" class="headerlink" title="二级结论"></a>二级结论</h2></li>
<li><h3 id="上三角行列式"><a href="#上三角行列式" class="headerlink" title="上三角行列式"></a>上三角行列式</h3><pre><code>    的值D = 对角线元素乘积</code></pre></li>
<li><h3 id="n阶行列式的性质"><a href="#n阶行列式的性质" class="headerlink" title="n阶行列式的性质"></a>n阶行列式的性质</h3><pre><code>    1. 行列式等于它的转置行列式
    2. 互换行列式中的两行/列,行列式变号(**行列式是一个值数,与矩阵不同**),那矩阵换行呢**??**
    3. 行列式有两行/列对应相等或者对应成比例,行列式 = 0或者行列式有一行全为0,行列式也为0
    4. 行列式乘一个数,就乘一行,跟矩阵一样??
    5. 最重要的来了: 把某一行/列元素的k倍加到另一行/列,行列式的值不变不变不变!
    6. 可以用上述这些进行行列式的计算</code></pre></li>
<li><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><pre><code>    1. 一个特殊行列式: 范德蒙Vandermonde</code></pre></li>
<li>可交换矩阵commutable: 数量矩阵与同阶任何矩阵,A与单位阵,对角阵与对角阵</li>
<li>方阵的幂</li>
<li>矩阵的初等变换: 极其类似行列式的初等变换</li>
</ul>
</li>
</ol>
<h2 id="疑问疑惑不理解"><a href="#疑问疑惑不理解" class="headerlink" title="疑问疑惑不理解"></a>疑问疑惑不理解</h2><ol>
<li>矩阵这么乘啊加啊,它行列式的值不会变吗,为什么可以这样</li>
<li>转化成ref</li>
<li>怎么用矩阵解三元一次方程(就像解eigenvector)  </li>
<li>我记得我总结过行列式与矩阵的不同??</li>
<li>记得PPT最后的几个性质 PPT的例题----可以lab时候做---<em>于10.31</em></li>
</ol>
<h2 id="难点和做题总结"><a href="#难点和做题总结" class="headerlink" title="难点和做题总结"></a>难点和做题总结</h2><ol>
<li>求特征向量的时候,就设xyz根据向量积的基本法则求,它们积是0.</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>2019</category>
        <category>KCL</category>
        <category>CMTE</category>
      </categories>
      <tags>
        <tag>空间向量</tag>
      </tags>
  </entry>
</search>
