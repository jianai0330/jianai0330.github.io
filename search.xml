<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>系统们的更新日志</title>
      <link href="/2021/07/05/updateeveryday/"/>
      <url>/2021/07/05/updateeveryday/</url>
      
        <content type="html"><![CDATA[<h1 id="少出岔子-ok💢"><a href="#少出岔子-ok💢" class="headerlink" title="少出岔子 ok💢"></a>少出岔子 ok💢</h1><span id="more"></span><ol><li>21.7.5<ol><li><a href="https://blog.csdn.net/weixin_43074462/article/details/100716511">按e把splash后面的参数修改成了nomodeset</a><ul><li>但是是一次性的 不是一劳永逸</li></ul></li><li>所以进入系统后编辑<code>sudo vi /etc/default/grub </code>, 修改为<code>GRUB_CMDLINE_LINUX_DEFAULT=“quiet splash nomodeset”</code>，最后更新<code>sudo update-grub</code><ul><li>重启后顺利开机</li><li>但是，开机第一幕自动grub没解决</li></ul></li><li>解决自动进入grub<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo grub-install <span class="regexp">/dev/</span>sda</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> UbuntuRecovery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系结构note</title>
      <link href="/2021/07/05/wuhannote/"/>
      <url>/2021/07/05/wuhannote/</url>
      
        <content type="html"><![CDATA[<h1 id="Summer-Intern-21年6-8月"><a href="#Summer-Intern-21年6-8月" class="headerlink" title="Summer Intern 21年6-8月"></a>Summer Intern 21年6-8月</h1><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="国防科大公开课"><a href="#国防科大公开课" class="headerlink" title="国防科大公开课"></a>国防科大公开课</h2><p><a href="https://www.bilibili.com/video/BV1aJ411g7LM?p=2">计算机体系结构国防科大35讲</a></p><span id="more"></span><ol><li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><p>冯诺依曼结构</p></li><li><p>20世纪80年代以来：RISC（精简指令集计算机）–指令集并行（流水线；多指令发射）；缓存</p><ul><li>20世纪80年代出现了个人计算机和工作站，因为有微处理器可供使用</li><li>80年代初RISC出现 –简化了指令系统，把更多的芯片硅面积用于实现<code>流水</code>和<code>cache</code></li><li>20世纪80年代，单片芯片上集成到25000-50000个晶体管</li></ul></li><li><p>ISA（Instruction Set Architecture指令集体系结构）：区分软硬件的界限</p><ul><li>80x86<ol><li>16个通用寄存器，16个存入浮点数据的寄存器</li><li><code>寄存器-存储器</code>ISA：在许多指令中，访问存储器</li><li>编码为可变长度，变化长度为1–18个<code>字节</code> – 可变长度的指令可以占用较少的空间</li></ol></li><li>ARM<ol><li><code>载入-存储</code>ISA（只能用load/store来访问存储器，所有最新的ISA都采用载入-存储ISA）</li><li>所有ARM和MIPS指令都是的长度都是32位</li></ol></li><li>MIPS<ol><li>32个通用寄存器，32个浮点寄存器</li><li><code>载入-存储</code>ISA（只能用load/store来访问存储器）</li></ol></li></ul></li><li><p>intel和ARM（都是ISA）  （CISC和RISC）</p><ul><li><a href="https://zhuanlan.zhihu.com/p/21266987">知乎一篇文章</a></li><li>ARM和Intel 两种架构，X86无法做到ARM的功耗，而ARM也无法做到X86的性能</li><li>ARM从来只是设计<code>低功耗处理器</code>，Intel的强项是设计<code>超高性能</code>的台式机和服务器处理器。</li><li>Intel i7处理器平均发热功率为45w，ARM是1/15</li><li>制造工艺的纳米数越小，能量的使用效率越高</li><li>ARM的big.LITTLE架构是一项Intel一时无法复制的创新 –处理器中的核可以有不同的性能和功耗</li><li>前端设计体现了处理器的构架，精简指令集和复杂指令集的区别是通过前端设计体现的</li><li>后端设计处理电压，时钟等问题，是耗电的直接因素。</li><li>移动处理器都是片上系统(SoC)架构，也就是说，处理器之外，图形，视频，音频，网络等功能都在一个芯片里。这些模块的打开与关闭就容易预测的多，并且可以通过软件来控制。这样，整体功耗就更加取决于软件和制造工艺而不是处理机架构。在这点上，X86的处理器占优势，因为Intel的工艺有很大优势</li><li><code>疑惑</code>：<ol><li>ARM处理器的乱序执行能力不如intel–intel加入乱序逻辑结构，因为ARM是异构，就没有这方面的问题（一个核顺序执行，一个核乱序执行）</li></ol></li></ul></li><li><p>存储器寻址与寻址模式</p><ol><li>字节寻址 ： 对齐</li><li><code>寻址模式</code>：<ol><li>MIPS寻址模式：<ul><li>寄存器寻址</li><li>立即数寻址</li><li>位移量寻址 ：讲固定偏移量加到寄存器得出存储器地址</li></ul></li><li>80x86 ：<ul><li>寄存器</li><li>立即数</li><li>位移量 ： 分三种。。。</li></ul></li><li>ARM ：<ul><li>寄存器</li><li>立即数</li><li>位移量</li><li>PC（程序计数器）的寻址方式</li><li>两个寄存器之和</li><li>自动递增寻址/自动递减寻址</li></ul></li></ol></li></ol></li><li><p>宽带和吞吐量：在给定时间内完成的总工作量</p></li><li><p>集成电路中的功率和能耗：</p><ol><li>功率：单位时间的能耗</li><li>能耗 与 该晶体管驱动的容性负载与电压平方的乘积成正比</li><li>缩减元件之间的间距之后，晶体管之间的电容也会降低，晶体管的开关频率也得以提升，从而整个芯片的工作频率就上去了。</li><li>晶体管的尺寸缩小会减低它们的内阻，所需导通电压会降低，这代表着CPU的工作电压会降低</li><li>动态随机存取存储器（Dynamic Random Access Memory，DRAM）是一种半导体存储器，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特（bit）是1还是0。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别数据，而导致数据毁损。因此对于DRAM来说，周期性地充电是一个无可避免的要件。由于这种需要定时刷新的特性，因此被称为“动态”存储器。相对来说，静态存储器（SRAM）只要存入数据后，纵使不刷新也不会丢失记忆。</li></ol></li><li><p>可信任度：</p><ol><li>模块可靠性：对发生故障之前的时间度量 MTTF MTTR</li></ol></li><li><p><code>时钟周期</code>是计算机中最基本的、最小的时间单位。 在一个时钟周期内，CPU仅完成一个最基本的动作。 时钟周期是一个时间的量。</p><ul><li>1993年的奔腾支持超流水线，一个时钟周期可以执行两条整数运算命令</li><li>现在的时钟周期有的是<code>0.几ns</code>；</li></ul></li><li><p>CPU到内存时间还是不够快，有时候要几百个时钟周期。所以内存和cpu之间还有2–3级<code>缓存</code></p></li></ol></li></ol><div  align="center">    <img src="../图片/计算机体系结构/程序执行和指令的操作.png" width = "300" height = "200" alt="bpp" align=center />    </div>    程序执行的过程 --控制流 数据流    <div  align="center">    <img src="../图片/计算机体系结构/计算机的属性.png" width = "300" height = "200" alt="bpp" align=center />    </div>    程序员能看到的计算机的属性    <div  align="center">    <img src="../图片/计算机体系结构/指令集结构的逻辑实现.png" width = "300" height = "200" alt="bpp" align=center />    </div>    指令集结构的逻辑实现<pre><code>20. 系列机和兼容    1. family machine：具有相同体系机构，但组成和实现不同    2. 软件兼容software compatibility ： 同一个软件-不加修改-获得相同结果（兼容种类也可以细分为二进制级兼容，汇编级兼容等）    3. 兼容机：支持软件兼容的硬件基础    4. 兼容性（向下向上：高低档机器先前向后：不同时期投入市场）   --兼容性up 寿命up        向后兼容：软件兼容的根本特征</code></pre><ol start="2"><li><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ol><li>计算机的分代（从91年以后是第五代：高性能微处理器+大规模高密度电路）</li><li>软件的发展：</li><li>处理器性能的提高，从单纯依赖指令集并行（ILP）转向数据级并行（DLP）和线程级并行（TLP）<ul><li>指令 和 线程</li><li>数据级并行DLP：同时操作许多数据项</li><li>任务/线程级并行：？？？</li><li>戴老师讲：数据级并行其实就是许多人用用一个指令处理一堆不同的数据</li></ul></li><li>计算机的分类：<ol><li>个人移动设备PMD（手机平板）</li><li>台式机</li><li>服务器：<pre><code> - 可用性 ： 要不间断的能使用，安全 - 可拓展性 ： 满足对功能的增长需求 ， 拓展计算容量，内存，I/O带宽</code></pre></li><li>仓库级计算机（WSC）</li><li>嵌入式：能否运行第三方软件<br>根据并行分：<ol><li>SISD</li><li>SIMD：数据级并行，同一指令由多个使用不同数据流的处理器执行</li><li>MISD</li><li>MIMD：多指令 多数据  –针对的是任务级并行</li></ol></li></ol></li><li>应用的发展：<ul><li>桌面计算：笔记本，工作站…（竞争激烈的市场）</li><li>服务器计算：可靠性做为追求目标</li><li>嵌入式计算：打印机，物联网…</li></ul></li><li>体系结构的发展：对结构的不断改良<ul><li>分布的IO处理能力：IO装置具有独立的处理能力：打印机，把游戏指令发给显卡后显卡会主动生成怪物      —-有效减轻cpu处理负荷</li><li>保护的存储器空间：数据和程序严格割裂开，有利于程序的保护和发展</li><li>存储器组织结构的发展</li><li><code>并行处理技术</code></li><li>指令集发展：用户可以定义自己的指令系统 效率up</li></ul></li><li>并行处理技术的发展<ol><li>并行性概念：<ol><li><strong><code>指令级并行</code></strong><ol><li>2002年以来，性能增长下降约20% —&gt; 可以进一步有效开发的指令级并行已经很少  —&gt;04年，从单纯依靠指令级并行转向线程级并行和数据级并行</li></ol></li><li><code>线程级并行</code></li></ol></li><li>提高并行性的技术途径 ：时间重叠（用流水线，同时处理多个指令，每个指令都可以处于不同的阶段），资源重复（一个cpu不够用多个，数量取胜原则），资源共享（提高资源的利用效率，多个人使用一个打印机）</li><li>并行计算的应用需求：对计算机的长远需求：工业设计 大气污染 天气预报等等</li></ol></li><li>计算机系统的成本和价格</li><li>思考一些问题： 软件兼容的例子；列举操作系统为上层应用提供的典型API有哪些，功能是什么</li><li>集成电路的发展和<code>摩尔定律</code>：“集成电路密度大概每两年翻一番—摩尔定律”  摩尔定律，也就是说，当价格保持不变时，集成电路上可容纳的晶体管数量每18个月增加一倍，性能提高一倍<table><thead><tr><th>时间</th><th>生产工艺</th><th>cpu晶体管数量</th></tr></thead><tbody><tr><td>2000 奔腾4威拉米特</td><td>180nm</td><td>4200万</td></tr><tr><td>2010  Corei7≤980X</td><td>32nm</td><td>11亿6999万9999个</td></tr><tr><td>2013核心i7 4960X</td><td>22nm</td><td>18.6亿</td></tr></tbody></table></li></ol></li><li><h3 id="计算机系统设计和分析"><a href="#计算机系统设计和分析" class="headerlink" title="计算机系统设计和分析"></a>计算机系统设计和分析</h3><ol><li><p>成本与价格 ：晶圆晶片制造，测试成本，封装。。。</p></li><li><p>基准测试程序： <a href="www.SPEC.org">测试程序包</a></p></li><li><p>量化设计的基本原则</p><ol><li><p>大概率事件优先原则：追求全局的最优结果</p><ul><li>赋予优先处理权和资源使用权</li></ul></li><li><p>Amdahl定律：通过对系统加速比的研究，来找到系统中占有最重要的部件（可以定量计算）</p><ul><li>假设对机器部件的改进，来计算加速比</li><li>如下：  <div  align="center">  <img src="../图片/计算机体系结构/amdahl定律1.png" width = "400" height = "200" alt="bpp" align=center />  </div>  系统加速比的公式  系统加速比依赖于两个因素：可改进比例，部件加速比</li><li>性能增加的递减规则：针对改进的某一部分，改进越多，效果越小</li><li>公式的引申和推论：<ul><li>对于整个任务的一部分进行优化，则<code>最大加速比</code>不大于1/(1-可改进比例)</li></ul></li></ul></li><li><p>Amdahl定律的计算练习</p></li><li><p>程序的<code>局部性</code>原理：程序执行时所访问的存储器在<code>时空</code>上是相对的簇聚（这种簇聚包括指令和数据两部分）: 时间局部性 空间局部性 生产-消费局部性</p></li></ol></li></ol></li><li><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><ol><li><p>指令集结构概述</p><ol><li>每条指令都是直接由cpu硬件执行<br> CPU插播：进入工厂的原料(程序指令)，经过物资分配部门(控制单元)的调度分配，被送往生产线(逻辑运算单元)，生产出成品(处理后的数据)后，再存储在仓库(储存单元)中，最后等着拿到市场上去卖(交由应用程序使用)</li><li>指令的表示：二进制格式…</li><li>指令的操作非常简单，其操作由操作码编码表示，每个操作需要的操作数个数为0-3个不等   –操作数是一些<code>存储单元</code>的地址(典型的存储单元：主存，寄存器，堆栈和累加器)</li><li><code>指令集与计算机的性能</code> T<ul><li>指令集在程序中：软硬件的接口</li></ul></li></ol></li><li><p>指令集结构的分类：</p><ul><li>在cpu中<code>操作数</code>的存储方法</li><li><div  align="center">  <img src="../图片/计算机体系结构/指令集结构的分类.png" width = "300" height = "200" alt="指令集结构的分类" align=center />  </div>  几种分类（堆栈；累加器等）</li><li><div  align="center">  <img src="../图片/计算机体系结构/通用寄存器型指令集结构的分类.png" width = "300" height = "200" alt="通用寄存器型指令集结构" align=center />  </div>   通用寄存器型指令集结构的分类  -------？</li><li>由此， 三种通用寄存器型指令集结构的优缺点: 寄存器-寄存器（0，3）；寄存器-存储器型（1，2）；存储器-存储器型（3，3）</li><li><div  align="center">  <img src="../图片/计算机体系结构/指令集结构设计概观.png" width = "300" height = "200" alt="指令集结构设计概观" align=center />  </div>  指令集结构设计概观</li></ul></li><li><p>存储器寻址：几乎所有都使用<code>字节寻址</code>来访问存储器操作数</p><ul><li>ARM+MIPS要求操作对象必须是对齐的</li></ul></li><li><p>存储器寻址与寻址模式</p><ol><li>字节寻址 ： 对齐</li><li><code>寻址模式</code>：<ol><li>MIPS寻址模式：<ul><li>寄存器寻址</li><li>立即数寻址</li><li>位移量寻址 ：讲固定偏移量加到寄存器得出存储器地址</li></ul></li><li>80x86 ：<ul><li>寄存器</li><li>立即数</li><li>位移量 ： 分三种。。。</li></ul></li><li>ARM ：<ul><li>寄存器</li><li>立即数</li><li>位移量</li><li>PC（程序计数器）的寻址方式</li><li>两个寄存器之和</li><li>自动递增寻址/自动递减寻址</li></ul></li></ol></li></ol></li><li><p>寻址方式：寄存器寻址；立即值寻址；偏移寻址；寄存器间接寻址（没有偏移量，值得注意的是：<code>(R1)</code>表示的是以R1的<code>地址</code>为内容的）；索引寻址（一般可用于对数组的访问）；直接寻址或绝对寻址；存储器间接寻址；自增/减寻址；缩放寻址</p><ul><li>e.g.<code> Add R1, (1001)</code> —这属于直接寻址，1001是地址， 这条指令的含义就为：<code>Regs[R1]&lt;-Regs[R1]+Mem[1001]</code>，这里的Mem[1001]就是地址为1001的寄存器里的内容。变量Mem用来表示存储器中的一个数组，存储按照字节寻址，它可以传送任何数目的字节。</li><li>e.g. <code>Add R1,@(R3)</code> —存储器间接寻址，含义为：<code>Reg[R1]&lt;-Regs[R1]+Mem[Mem[Regs[R3]]]</code>首先访问寄存器，取出一个存储单元的地址，再访问该存储单元，取出保存操作数的那个存储单元的地址，再通过一次访存，得到操作数。   （只是加深理解，基本不会使用）</li></ul></li><li><p>MIPS的指令格式：</p><div  align="center"><img src="../图片/计算机体系结构/MIPS指令格式.png" width = "450" height = "200" alt="MIPS指令格式" align=center /></div></li></ol><p> <a href="http://www.yuejianzun.xyz/2018/02/18/MIPS%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">MIPS指令基本格式一篇文章</a></p><ol start="4"><li>指令系统的设计和优化<ol><li>引入控制指令概念：Jump（跳转），Branch</li><li>过程调用和返回的状态保存（调用者保存 被调用者保存–一般用它）</li></ol></li><li>指令系统的发展和改进<ul><li>强化指令功能，软件功能向硬件功能转移（CISC）</li><li>RISC：在向着它发展</li></ul></li><li>操作数的类型和大小</li><li>MIPS指令系统结构<ol><li>操作数保存在寄存器里，所以只能通过load/store指令来访问存储器</li><li>MIPS是一种多元指令结构，注重指令流水效率</li><li>有32个32位的通用寄存器，R0的内容恒为0；32个32位浮点寄存器</li><li>支持：寄存器寻址，立即值寻址，偏移寻址，寄存器间接寻址。</li><li>操作类型：&lt;-,##,</li></ol></li></ol></li><li><h3 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h3><ol><li><h4 id="流水线基本概念-：硬件资源降到最低程度"><a href="#流水线基本概念-：硬件资源降到最低程度" class="headerlink" title="流水线基本概念  ：硬件资源降到最低程度"></a>流水线基本概念  ：硬件资源降到最低程度</h4><ol><li>指令流水线</li><li>功能部件流水线</li><li>用时空图来描述：横时间，纵各流水线</li><li>特点：<ol><li>级/段；深度</li></ol></li><li>流水线的分类：<ol><li>（按流水线 完成的 功能 分类）<ol><li>单功能流水线 ： 只能完成一种固定功能的流水线</li><li>多功能流水线 ： 各段进行不同的连接，例如：TI ASC</li></ol></li><li>按连接方式<ol><li>静态流水线 ：TI ASC</li><li>动态流水线 ： 重叠在一起，可能会冲突</li></ol></li><li>按级别<ol><li>部件级进行流水</li><li>指令流水线</li><li>处理机间流水线–宏流水线</li></ol></li><li>按数据表示<ol><li>标量流水处理机 ： 仅对标量进行数据处理</li><li>向量流水处理机 ： 例如TI ASC</li></ol></li><li>是否有反馈回路<ol><li>线性流水线</li><li>非线性 ： 有可能在汇集点冲突 —流水线调度问题</li></ol></li></ol></li></ol></li><li><h4 id="MIPS基本流水线："><a href="#MIPS基本流水线：" class="headerlink" title="MIPS基本流水线："></a>MIPS基本流水线：</h4><ol><li>非流水方式</li><li>划分为5个阶段：<ol><li>取指令（IF）：<ul><li>根据PC值从存储器取出指令，并将指令送入指令寄存器IR；PC++（指向下一条指令）；并将下一条指令的的地址放入临时寄存器NPC中   —ps：指令的地址就是pc的值吗</li></ul></li><li>译码/读寄存器（ID）：<ul><li>进行指令译码，读IR寄存器（指令寄存器），按照相应寄存器号读寄存器文件，…</li></ul></li><li>执行/有效地址计算周期（EX）：<ul><li>，</li></ul></li><li>访存/分支操作完成周期（MEM）</li><li>写回周期（WB）</li><li>性能分析<ol start="7"><li>？？？？？</li></ol></li></ol></li></ol></li><li>流水线中的相关<ol><li>流水线性能分析<br> 三项性能指标：吞吐率；最大吞吐率；实际吞吐率<pre><code> - 吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量 - 最大吞吐率：流水线达到稳定状态后所得到的吞吐率     瓶颈 ---细分瓶颈段，重复设置瓶颈段（并列的）     有一个吞吐率的计算 题型 - 假设流水线各段的时间相等</code></pre></li><li>加速比： 流水线速度：等功能非流水线速度</li><li>效率：流水线的设备利用率<ol><li>从时空图上看，时空区面积之比</li><li>效率是：实际加速比与最大加速比之比</li></ol></li><li>锁存器 ： 对时钟扭曲不敏感</li><li>什么是相关？ –相邻/近的两条指令因存在某种关联，后一条指令不能在原先指定的时钟周期开始执行</li><li>消除相关的基本方法：暂停（低效）</li><li>三种不同类型的相关：<ul><li>结构相关：硬件资源满足不了重叠执行的要求<br>  原因：<pre><code>  - 功能部件不是全流水  - 重复设置的资源数量不足</code></pre>  避免：<pre><code>  - 所有功能单元完全流水化  - 设置足够多的硬件资源 （硬件代价很大）</code></pre></li><li>数据相关：要用到前面指令的结果<ol><li>定向技术forwarding（可以减少数据相关带来的暂停），也称为旁路（bypassing）：</li></ol></li><li>控制相关：遇到分支指令/改变pc值的指令</li></ul></li></ol></li><li>实例分析：MIPS R4000</li><li>向量处理机</li></ol></li></ol><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ol><li><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3></li></ol><h2 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h2><ol><li>IPv4地址由32位二进制数组成，即地址字节数为4 xxx.xxx.xxx.xxx (xxx是小于255的十进制数，换算成2进制就是小于8位)<ul><li>将地址长度扩大至 IPv4 地址的 4 倍， 即由 32bit 扩展至128bit ，即16个地址字节数</li><li>为互联网上的每一个网络和每一台主机分配一个逻辑地址</li><li>MAC（Media Access Control或者Medium Access Control）地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置</li><li>存储器地址（Memory address）是存储器中存储单元的编号。 –32位操作系统存储器地址字节为4个字节，64位操作系统存储器地址字节为8个字节<ul><li>一个字节（byte）就是8bit</li><li><strong>1kb是1024byte</strong>，1024*8位数字</li></ul></li></ul></li><li>半导体：关系到CPU内能塞进多少个晶体管，CPU所能达到的频率还有它的功耗<ol><li>ss</li></ol></li></ol><table><thead><tr><th>1978年</th><th>3000nm生产工艺</th><th>29000个晶体</th><th>工作频率5MHz</th></tr></thead><tbody><tr><td>28核Skylake-SP Xeon</td><td>14nm生产工艺</td><td>超过80亿个晶体管</td><td>5GHz（Core i9-9900K）｜</td></tr></tbody></table><pre><code>我们所说的生产工艺是指线宽，也就是芯片上的最基本功能单位门电路的宽度，因为实际上门电路之间连线的宽度同门电路的宽度相同，所以线宽可以描述制造工艺制造工艺用特征尺寸来衡量，即一个晶体管或一条连线在x/y的最小尺寸</code></pre><ol start="3"><li>晶圆 晶片 集成电路 芯片 核 cpu 主板 内存 等等的关系：<ol><li>硅晶圆尺寸越大越好，因为这样每块晶圆能生产更多的芯片。<ul><li>无法随心所欲地增大晶圆尺寸： 生产过程中，离晶圆中心越远就越容易出现坏点</li><li>晶体管在处理器上集成，晶体管与晶体管之间用金属线路连接（金属线路的容量直接影响信息传送的速度）</li></ul></li><li>了解cpu的制作流程 ：<ol><li>切割晶圆 ： 用机器从单晶硅棒上切割下一片事先确定规格的硅晶片，并将其划分成多个细小的区域，每个区域都将成为一个CPU的内核（Die）</li><li>紫外线通过<code>印制着CPU复杂电路结构图样</code>的模板照射硅基片，被紫外线照射的地方光阻物质溶解</li><li>下一步就是蚀刻（etching）：结合上面制造的基片，CPU的门电路就完成了</li><li>重复；分层：3d结构，7–9层，层数决定于设计时CPU的布局，以及通过的电流大小</li><li>封装：封入一个陶瓷的或塑料的封壳中，这样它就可以很容易地装在一块电路板上</li></ol></li><li>芯片是半导体元件产品的统称，是集成电路的载体，由晶圆分割而成。<ul><li>集成电路包括半导体芯片及外围相关电路（电阻电容二极管）</li><li>芯片是“集成电路”的俗称。集成电路有模拟集成电路和数字集成电路，如果一片集成电路（芯片）中既有模拟电路又有数字电路，则称其为数模混合集成电路</li><li>CPU是中央处理器，包含运算器和控制器，是数字电路。如果将运算器和控制器集成在一片集成电路上，就称之为微处理器。目前人们将中央处理器与微处理器已经混为一谈了</li><li>so，CPU是一种数字芯片，只是众多芯片中的一类</li><li>一块晶圆上可以切割出数百个处理器(晶体管：50-200nm尺寸)</li></ul></li><li>晶体管相当于开关，控制着电流的方向（一个针头上就能放下大约3000万个晶体管）。</li></ol></li><li>线程进程程序：<ol><li>一个程序包含着若干个进程，一个进程包含着若干个线程。</li></ol></li></ol><ol start="10"><li><kbd>这是什么</kbd><table><tr>    <th rowspan="2">真实情况</th>    <th colspan="2">预测结果</th></tr><tr>    <td>正例</td>    <td>反例</td></tr><tr>    <td>正例</td>    <td>TP(真正例)</td>    <td>FN(假反例)</td></tr><tr>    <td>反例</td>    <td>FP(假正例)</td>    <td>TN(真反例)</td></tr></table></li></ol><h2 id="疑问疑难"><a href="#疑问疑难" class="headerlink" title="疑问疑难"></a>疑问疑难</h2><ol><li>Mem[]和Regs[]的理解：Mem的方括号里是表示地址的一串数字，Mem[]表达的是内容       —-所以表示地址的和表示内容的其实是长度相同的一串二进制数字吗？？？       Regs[]表示的是数值</li><li> (7.1早上，周四) 数据级并行，指令集并行，任务级并行，线程级并行；SIMD，MIMD等。深入梳理</li><li> 核 整理 core multi-core</li><li>各种频率的理解<ol><li>手机 cpu频率2.xGHz（两千多MHz）</li><li>内存条的频率 最大到三千兆赫兹（3000MHz）</li></ol></li><li>PCI SATA这些是什么</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2021 </category>
          
          <category> Summer </category>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VAD</title>
      <link href="/2021/07/05/vad/"/>
      <url>/2021/07/05/vad/</url>
      
        <content type="html"><![CDATA[<h2 id="VAD-Paper"><a href="#VAD-Paper" class="headerlink" title="VAD- -Paper"></a>VAD- -Paper</h2><ol><li><h3 id="Kobe-Japan的"><a href="#Kobe-Japan的" class="headerlink" title="Kobe Japan的"></a>Kobe Japan的</h3><ol><li><p>概念上：VAD:话语激活检测</p><ol><li>当用户的语音信号能量低于一定门限值时就认为是静默状态，也不发送语音分组。当检测到突发的活动声音时才生成语音信号，并加以传输。<span id="more"></span></li><li>从一段语音（纯净或带噪）信号中标识出语音片段与非语音片段</li><li>ADC：模拟数字转换器，模拟信号转变为数字信号</li><li>FPGA board： Field－Programmable Gate Array的缩写，即现场可编程门阵列。</li><li>第一步就是提取噪音信息。通常的思路是通过VAD函数得到非语音片段，而非语音片段可以认为是纯噪音片段。从而可以从纯噪音信号中提取出有用信息，例如进行傅里叶变换得到噪音频谱等，再进而做下一步处理。例如谱减法，维纳滤波。</li><li>zero cross counter (ZCC)： 过零率，一帧语音时域信号穿过0（时间轴）的次数。 语音片段ZCC较小，非语音片段ZCC较大</li><li>STE：short time energy：短时能量</li><li>我们通常使用麦克风进行音频录制的采样率为 16000Hz，一个采样点使用 16bit 来存储。</li><li>ksps：单位，kilo Samples per Second ，即采样千次每秒，是转化速率的单位。</li><li>dB：分贝</li><li>S/N：信噪比（单位是分贝），信号与噪声的比例。设备的信噪比越高表明它产生的噪声越少。越高越好。</li><li>d-flip flop：d触发器，两个稳定状态，即”0”和”1”</li></ol></li><li><p>语音识别的特征提取</p><ol><li>(一篇知乎上的文章)[<a href="https://zhuanlan.zhihu.com/p/147386972]">https://zhuanlan.zhihu.com/p/147386972]</a> ：根据语音信号-&gt;预加重-&gt;分帧加窗-&gt;DFT-&gt;等等的流程来介绍</li></ol></li><li><p>这篇文章：通过zero-crossing VAD algorithm判断speech或噪音，利用的原理就是把语音输入现转化为连续数字信号，再判断在某时刻该信号是否穿过x轴，如果这个input signal在该点的前一个峰值pass了设定的trigger line，那么它就是zero crossing，count相应+1.我们再根据某一段信号中zero crossing点出现的相对频率来判断这段信号到底是speech还是noise。用sum（用于记录zerocrossing数量的变量）/帧的长度来进行比较     （用中文做流程图）  。<br> 他们团队没有使用单片机，而是使用了FPGA芯片<br> 他们在陈述结果时，根据范围从-20—-20dB的信噪比的变化，用了Correct，False accptance和False rejection</p></li><li><p>好处坏处，改进的</p><ul><li>   ，，</li><li>   没有关注人说了什么什么，只要人发出声音就会被识别</li></ul></li><li><p>我得想法和思考</p></li><li><p>不懂的地方</p></li><li><p>结合看的相关其他文章</p></li></ol></li><li><h3 id="智能手表VADLite系统"><a href="#智能手表VADLite系统" class="headerlink" title="智能手表VADLite系统"></a>智能手表VADLite系统</h3><ol><li>这个团队研发的开源系统，是在智能手表上可以安装下载的app。</li><li>目的是结合他们以前有关于人体健康数据的智能产品，使得手表在用户呼叫的时候才会收集心率心跳等数据</li><li>data preprocessing：他们收集了至少10个处于不同距离的不同的人对着手表讲话后的数据，一共3.5h。他们用了一个静默识别的算法来截取掉大部分安静的语音片段。 —–计算RMS（root mean square均方根），如果这个数值低于一个他们用离散点图确定下来的特定值，就标记为silence。  —》然后用SVM来识别人声和噪声—》分成25ms一帧，提取12 MFCC features—-》再用linear SVM来识别和分类。具体来说：</li></ol></li><li><h3 id="Tiny-Voice"><a href="#Tiny-Voice" class="headerlink" title="Tiny Voice"></a>Tiny Voice</h3><ol><li><p>，，</p></li><li><p>。。。</p></li><li><p>选择存储器：</p><ol><li>好处比较</li></ol></li><li><p>interface 功能和规则 + 具体的用汇编语言写的软件： 结合起来用两张图放在一起，一起来说。</p></li></ol></li></ol><pre><code>5. 我认为timer等一些想法或许我可以借鉴在我未来自己的设计中。它虽然很小，但并不是一个简单的系统。6. 不足：train的时候背景的噪音会对产生的template造成很大影响，从而影响recognize的效果。</code></pre><ol start="4"><li><h3 id="pre-—-for以上三paper-—-结合以slide（稿件草稿版）"><a href="#pre-—-for以上三paper-—-结合以slide（稿件草稿版）" class="headerlink" title="pre —-for以上三paper —-结合以slide（稿件草稿版）"></a>pre —-for以上三paper —-结合以slide（稿件草稿版）</h3> 可能耽误大家几分钟的时间，我将对我上个周阅读的三篇关于语音识别的文章向大家做一个简单的介绍和汇报。首先我会分别按照这三篇文章的大概脉络来说一下对这三种里面的算法啊应用啊我的理解，然后在最后总结的时候，我会横向比较一下这三个，说一下我的理解和困惑<ol><li>感觉这三篇都没有着重讲算法的实现和理论的公式，所以对于我来说比较好理解。 我首先会简单介绍文章中所提到的它们的背景，目的等，我可能要简单说一下硬件部分，着重讲一下我所理解的，他们实现VAD的方法。最后我会比较和总结一下这三种应用，说一下自己的思考和一些困惑。</li><li>介绍第一篇论文：在一个智能通用传感器系统里，为了能够减少能耗，他们设计和应用了这个VAD模块。就是当vad没有识别到语音信号的时候，这个系统的其他电路都是没通电的。<ol><li>。。。</li><li>我不熟悉画这种图所以引用了一张原文的图片    着重的是这两点     这个帧长根据文中的描述应该是256</li><li>不足：文章中也提到，相比于一些frequency domain algorithm ，我们的zero crossing算法作为基于时域的，在信噪比比较低的情况下准确率一般<ol start="2"><li>然后我可能对于这两条trigger line的确定方法不是很懂 –结尾</li></ol></li></ol></li><li>。。</li><li>第二篇VADLite（手表）：<ol><li>来自苏黎世联邦理工大学的开源项目</li><li>设计初衷是希望与他们之前的智能人体健康数据产品相结合，使得在用户呼唤手表时，能够相应的测量和记录血压血样心率等等数据</li><li>下面这个图简单描述了系统的框架，分为两个模块。他们用了pipeline。</li><li>，，，</li><li>在预处理过程中，计算RMS（root mean square均方根），如果这个数值低于一个临界值，就标记为silence。静默片段的这个阈值是根据所有声音片段的RMS生成的离散点图确认的。</li><li>再到特征提取：他们团队使用了梅尔频率倒谱系数   —-并没有详细讲mfcc的基础知识，我只是简单了解了一下原理。（一组声音数据，分成很多帧，每一帧经过快速傅立叶变换FFT获得相应的频谱，然后再经过梅尔滤波器获得梅尔频谱，然后在梅尔频谱上进行倒谱分析–取第2-13个系数）</li><li>在分类里，用了线性SVM。（一种监督学习的方法，我对SVM的理解就是篮球红球，棍子分开），</li><li>用了网格搜索来调参–（常用的找最优超参数的算法）</li><li>标准化：介绍的是减去均值再除以方差</li></ol></li><li>。。。</li><li>第三篇呢是一个期刊上对于产品的介绍。<ol><li>，，，</li><li>他这个处理器是没有数字电路转换器的，所以他用了一个集成电路板来把时域信号转化成单片机能够识别的信号</li><li>tiny voice的语音识别运用的理论基础就是把声音信号分为两个不同频率范围的共振峰区</li><li>high-pass filtered：高通滤波，过滤掉低频信号</li><li>硬件上用了这个只读存储器，在这里先略过。</li><li>对于</li><li>简略的flowchart：<ul><li>recognize按下后的模式里。。。。。在没有阅读相似的源码的情况下，我觉得我还完全没有知其所以然</li></ul></li></ol></li><li>可能前面几页不够直观清晰，这一页我把他们放在一起，，</li><li></li><li>然后比较这三篇文章三种应用的话，我觉得相对于像tiny voice一样用不带ADC的处理器或者像FPGA这种半定制电路/逻辑门array，对于我这种初学者可能刚开始用一些比较好上手的单片机更好。</li><li>好像一些基本原理我都已经知其然了，但是具体的算法实现和理论基础（你比如说像MFCC和SVM）我还要加深理解才行，需要更多的阅读和实践</li><li>然后文章里具体描述的一些数据，采样频率等等我需要在自己的实践中慢慢来体会。</li></ol></li></ol><h2 id="stm32F750"><a href="#stm32F750" class="headerlink" title="stm32F750"></a>stm32F750</h2><ol><li><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><ol><li>公司：ARM；内核：Cortex-M3内核的32位闪存微控制器##  🌟VAD项目✨</li></ol></li><li>30 ： stm32<br>周四7.1: 了解stm32 （I/O，串口）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2021 </category>
          
          <category> Summer </category>
          
          <category> VAD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语音识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日总结</title>
      <link href="/2019/11/25/mei-ri-zong-jie/"/>
      <url>/2019/11/25/mei-ri-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>一切随缘好了,开心和积极向上是最重要的</p><span id="more"></span><h1 id="11-25-周一-week10"><a href="#11-25-周一-week10" class="headerlink" title="11.25 周一 week10"></a>11.25 周一 week10</h1><h2 id="吃了什么"><a href="#吃了什么" class="headerlink" title="吃了什么"></a>吃了什么</h2><ul><li>0.1:无</li><li>0.2:两个cheese roll,一袋李子</li><li>0.3:一个鸡蛋,半杯麦片,圣女果一袋</li></ul><hr><h2 id="今天的运动"><a href="#今天的运动" class="headerlink" title="今天的运动"></a>今天的运动</h2><h2 id="没有…除了去Sainsbury…"><a href="#没有…除了去Sainsbury…" class="headerlink" title="没有…除了去Sainsbury…"></a>没有…除了去Sainsbury…</h2><h2 id="今天的支出和收入"><a href="#今天的支出和收入" class="headerlink" title="今天的支出和收入"></a>今天的支出和收入</h2><ul><li>支出: 4.9</li><li>收入: 0</li></ul><hr><h2 id="今天的学习内容总结"><a href="#今天的学习内容总结" class="headerlink" title="今天的学习内容总结"></a>今天的学习内容总结</h2><ul><li>1.1: 把cmte本周的所有任务完成了</li><li>1.2: ppa做了很多,好的开展</li><li>1.3:</li><li>1.4:</li></ul><hr><h2 id="所以收获了什么呢"><a href="#所以收获了什么呢" class="headerlink" title="所以收获了什么呢"></a>所以收获了什么呢</h2><ul><li>2.1: 收获了快乐??还算不错</li><li>2.2:</li><li>2.3:</li><li>2.3:</li></ul><hr><h2 id="遗留的疑问是"><a href="#遗留的疑问是" class="headerlink" title="遗留的疑问是?"></a>遗留的疑问是?</h2><ul><li>3.1:</li><li>3.2:</li><li>3.3:</li><li>3.4:</li></ul><hr><h2 id="明天的计划是什么呢-周二"><a href="#明天的计划是什么呢-周二" class="headerlink" title="明天的计划是什么呢 周二"></a>明天的计划是什么呢 周二</h2><ul><li>4.1: 12点起床洗澡,用黄盒子带圣女果</li><li>4.2: 回看和作业 CS的</li><li>4.3: 看电影和吃东西 :给我把握好</li><li>4.4: ppa report要开始写了!</li><li>4.5: 看电影完适当购物: 腌莴笋的用品!!!</li><li>4.6: 睡前看PPA的回放</li><li>4.7:cscscs!!!</li></ul><hr><h2 id="心情好吗-有激情吗"><a href="#心情好吗-有激情吗" class="headerlink" title="心情好吗,有激情吗?"></a>心情好吗,有激情吗?</h2><ul><li>按照1---10打分</li><li>7 没有食欲,学习欲望一般 ---17:18</li><li>7 睡前</li></ul><hr><h1 id="近期待办的事务"><a href="#近期待办的事务" class="headerlink" title="近期待办的事务"></a>近期待办的事务</h1><ul><li>5.1: 黑五买两件大衣!</li><li>5.2:</li><li>5.3:</li></ul><hr><h1 id="Temple-周-week"><a href="#Temple-周-week" class="headerlink" title="Temple 周  week"></a>Temple 周  week</h1><h2 id="吃了什么-1"><a href="#吃了什么-1" class="headerlink" title="吃了什么"></a>吃了什么</h2><ul><li>0.1:</li><li>0.2:</li><li>0.3:</li></ul><hr><h2 id="今天的运动-1"><a href="#今天的运动-1" class="headerlink" title="今天的运动"></a>今天的运动</h2><hr><h2 id="今天的支出和收入-1"><a href="#今天的支出和收入-1" class="headerlink" title="今天的支出和收入"></a>今天的支出和收入</h2><ul><li>支出:</li><li>收入:</li></ul><hr><h2 id="今天的学习内容总结-1"><a href="#今天的学习内容总结-1" class="headerlink" title="今天的学习内容总结"></a>今天的学习内容总结</h2><ul><li>1.1:</li><li>1.2:</li><li>1.3:</li><li>1.4:</li></ul><hr><h2 id="所以收获了什么呢-1"><a href="#所以收获了什么呢-1" class="headerlink" title="所以收获了什么呢"></a>所以收获了什么呢</h2><ul><li>2.1:</li><li>2.2:</li><li>2.3:</li><li>2.3:</li></ul><hr><h2 id="遗留的疑问是-1"><a href="#遗留的疑问是-1" class="headerlink" title="遗留的疑问是?"></a>遗留的疑问是?</h2><ul><li>3.1:</li><li>3.2:</li><li>3.3:</li><li>3.4:</li></ul><hr><h2 id="明天的计划是什么呢"><a href="#明天的计划是什么呢" class="headerlink" title="明天的计划是什么呢"></a>明天的计划是什么呢</h2><ul><li>4.1:</li><li>4.2:</li><li>4.3:</li><li>4.4:</li></ul><hr><h2 id="心情好吗-有激情吗-1"><a href="#心情好吗-有激情吗-1" class="headerlink" title="心情好吗,有激情吗?"></a>心情好吗,有激情吗?</h2><ul><li>按照1---10打分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> life </category>
          
          <category> everynight </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FC</title>
      <link href="/2019/11/13/fc/"/>
      <url>/2019/11/13/fc/</url>
      
        <content type="html"><![CDATA[<h1 id="六-graphs-7-1"><a href="#六-graphs-7-1" class="headerlink" title="六 graphs 7.1"></a>六 graphs 7.1</h1><span id="more"></span><h2 id="PPT提纲-11-13-拖延症…"><a href="#PPT提纲-11-13-拖延症…" class="headerlink" title="PPT提纲 ---11.13 拖延症…"></a>PPT提纲 ---11.13 拖延症…</h2><ol><li>graph的种类:</li></ol><ul><li>simple(e.g.Niche overlap graphs in ecology): --------没方向undirected,没multiple edges,没loop edges</li><li>multigraph(e.g.Road networks):----------------没方向undirected,有multiple edges,有loop</li><li>directed graph(e.g.representing binary relations前几章学的):--有方向directed,没multiple edges,有loop</li><li>!开头比较三者的表格理解!</li></ul><ol start="2"><li><p>undirected graphs概念<br> 一些概念: 两个点相连 它们adjacent,此线edge incident with 两个点<br> degree:此点含线edge的条数<br>  由此有:isolated孤家寡人 &amp; pendant(一条,degree 1,垂饰很好理解)<br> Handshaking theorem:<strong>edge的条数=点们的degree的和/2</strong></p></li><li><p>directed graph的一些概念(它有方向!)<br> 起点is the initial or start vertex of 线,终点 is the terminal or end vertex of 线<br> in-degree:此点含作为终点的线的条数<br> out-degree:此点含作为起点的线的条数(注意loop一个圈的话是in和out都要算进去的)<br> 公式:线的条数=in/out</p></li><li><p>adjacency matrix</p></li><li><p>Path</p><ul><li>length:所包含edge的条数</li><li>Simple:doesnt contain the same <strong>edge</strong> twice</li><li>Hamiltonian path: 在simple的基础上passing every <strong>vertex 一次</strong></li></ul></li><li><p>cycle(可与path类比)</p></li><li><p>complete graph (n-clique)   n-cycle</p></li><li><p>subgraph</p></li><li><p>connected graphs   , conneed component</p></li><li><p>isomorphic同构 if isomorphism(保持结构的双射)  , invariant</p><p>​          </p></li></ol><h1 id="七-tree"><a href="#七-tree" class="headerlink" title="七 tree"></a>七 tree</h1><h2 id="PPT提纲预习-11-13"><a href="#PPT提纲预习-11-13" class="headerlink" title="PPT提纲预习 ----11.13"></a>PPT提纲<code>预习</code> ----11.13</h2><ol><li>定义: vertices,root,edge</li><li>edge是一条线,vertix是点 ?</li><li>rooted tree</li><li>parent,child,siblings. leaf,internal(vertices with at least one child)<br>ancestors(以上线上的所有),descendants</li><li>应用: binanry search trees &amp; decomposition trees</li><li>概念:level,height,balanced,subtree</li><li>m-ary tree, full m-ary tree,full binary tree</li><li>有几个二级结论:<ul><li>对于full binary tree :n internal vertices ------<strong>2n+1</strong> vertices</li><li>对于full m-ary  tree: n internal vertices ------<strong>m*n+1</strong> vertices</li></ul></li><li>逻辑式可以用二叉树</li><li>binary search trees : sorting linearly ordered list</li><li>tree traversal: preoder,inorder,postorder</li></ol><h2 id="课上-提纲"><a href="#课上-提纲" class="headerlink" title="课上 | 提纲"></a>课上 | 提纲</h2><ol><li>概念和定义<br> 什么是TREE</li></ol><ul><li><strong>simple</strong> graph with no simple cycles(有cycle就不是tree,必须要是connected的)</li><li>a unique simple path between任意两点</li><li>如果加一条edge，会产生cycle</li><li>如果减一条edge，会disconnected</li></ul><ol start="2"><li>rooted tree</li></ol><ul><li><p>特性是其中一个vertex被当作root（放在top）</p></li><li><p>两个rooted trees are <strong>isomorphic</strong> -----bijection</p><ul><li>root to rooted</li><li>edges to edges</li><li>non-edges to non-edges<br>  ？</li></ul></li><li><p>basic terminology</p><ul><li>特别注意internal vertices 和 leaves，一个有children，一个没有children。</li><li>leaves没children，是垂饰in graph？</li><li>level： 从root的0开始</li><li>height： 也要从0开始算！ height=层数-1！</li><li>balanced的概念理解过来就是每一个分支的长都要等于height或者height-1。</li><li></li></ul></li></ul><ol start="3"><li><p>几个特殊的tree和二级结论：</p><ul><li><p>m-ary treeM</p><ul><li>每一个internal的children不超过m</li></ul></li><li><p>full m-ary tree</p><ul><li>每一个internal的children等于m</li><li>不明白 这怎么可能？！</li></ul></li><li><p>full binary tree</p><ul><li>每一个internal 有2children</li></ul></li><li><p>m*n+1</p></li><li><p>logic formula</p></li></ul></li><li><p>BST</p><ul><li>注意linear order, partial order的概念</li><li>lexicographical order</li></ul></li><li><p>traversal遍历 三种</p></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>graph和tree里edgetoedge和nonedge到底是什么意思 怎么用</li></ol><h1 id="八-fc-11-17周日"><a href="#八-fc-11-17周日" class="headerlink" title="八 fc ---11.17周日"></a>八 fc ---11.17周日</h1><p>finite automata : finite-state machines</p><ol><li>preliminaries:alphabets and words</li></ol><ul><li>length</li><li>concatenation</li><li>prefix,suffix</li><li>language</li></ul><p>2.finite automation:a theoretical model for programs using a constant amount of memory regardless of the input form.</p><ul><li><p>finite <strong>control device</strong>:in any moment it can be in one of its <strong>states</strong>. it is hard-wired how it changes from one state to another.</p></li><li><p>states:(initial states,favourable states)</p></li><li><p>input tape:divied into cells</p></li><li><p>how it starts:</p><ul><li>the finite control device is in its unique initial state.<br>这句话是什么意思？？</li><li>the reminder</li></ul></li><li><p>how it works:</p><ul><li><p>moves the reading head</p></li><li><p>choose the next state of its control device???<br>这句话什么意思？？</p></li><li><p>the control device is hard-wired------the next state depends on</p><ul><li>the previous state</li><li>the character read from the tape</li></ul></li><li><p>ending:</p><ul><li>if control device is in a favourable state: the input word is accepted</li><li>otherwise: rejected</li></ul></li></ul></li><li><p><strong>state transition diagrams</strong></p><ul><li>directed multigraph<ul><li>点：the states</li><li>箭头线的标签：input</li></ul></li></ul></li></ul><h1 id="作业中易错点总结"><a href="#作业中易错点总结" class="headerlink" title="作业中易错点总结"></a>作业中易错点总结</h1><ol><li>---11.14 五 概率<ol><li>题型: 要运用贝叶斯定理的题目,1. 先画个<em>二叉树</em>帮助理解, 2. 计算时哪个包含哪个一定要搞清楚</li><li>判断indenpent: 三个公式</li></ol></li><li>---11.14 Small六<ul><li>六个工作分给五个人的答案没理解</li></ul></li><li>---11.14 六 graph<ul><li>isomorphic: f是bijection(one-to-one&amp;onto)</li><li>invariant</li><li>题型:判断一句话是否是invariant: 与onto和one-to-one结合为题目服务(例题好好理解)</li><li>题型:根据题干描述画graph时,注意看清楚给出的要求的类型!</li><li>题型:证明两个graph是isomorphic的: 画出图,再一一f对应</li><li>Largetutorial最后一题:只能说思维要开阔了…</li></ul></li></ol><h1 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h1><ol><li>---11.13 六graph里directed graph的计算edge的公式,一个点可以同时有in和out,且数量不同,那怎么算?</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> FC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PPA_notes</title>
      <link href="/2019/11/03/ppa/"/>
      <url>/2019/11/03/ppa/</url>
      
        <content type="html"><![CDATA[<h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><span id="more"></span><h3 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h3><ol><li>wihle loop</li><li>for-each</li><li><h4 id="searching"><a href="#searching" class="headerlink" title="searching:"></a>searching:</h4>  loop condition: <em>index &lt; files.size() &amp;&amp; !found</em></li><li>不要用input == “bye”比较两个string,一定要用只能用<p>input.equals(“bye”)</p></li><li>Iterator与iterator():<br>   iterator()是collection有的一个method,return一个Iterator类的object,这个object可以用这几个Iterator类里的method:<strong>hasNext,next,remove</strong><br>   格式:<code>Iterator&lt;ElementType&gt; it = myCollection.iterator()</code></li><li>Index vs Iterator:<strong>remove</strong>的时候用iterator,</li><li>anonymous objects: ?啥玩意儿,不管了</li></ol><h2 id="week7-Chapter6"><a href="#week7-Chapter6" class="headerlink" title="week7 Chapter6"></a>week7 Chapter6</h2><h3 id="研读课本"><a href="#研读课本" class="headerlink" title="研读课本"></a>研读课本</h3><ol><li>responsibility-driven design, cohesion, coupling, refactoring</li><li>intance method:invoked on an <strong>intance</strong> of a class, 注意class method和instance method不互通不能互相引用</li><li>enum(enumerated types):枚举<pre><code> 枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部</code></pre><h3 id="预习PPT-amp-提纲"><a href="#预习PPT-amp-提纲" class="headerlink" title="预习PPT&amp;提纲"></a>预习PPT&amp;提纲</h3></li><li>几个class:random</li><li>Set,Map<br>  hashSet,hashMap</li><li>list,map和set的比较</li><li>wrapper classes<br> int 和 Interger</li><li>autoboxing and unboxing</li><li>static</li></ol><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><h3 id="yi"><a href="#yi" class="headerlink" title="yi"></a>yi</h3><ol><li>为什么add（E e）返回的是boolean</li><li>random的引用</li><li>selecting random responses<ul><li>responses的arraylist是怎么产生的</li></ul></li></ol><h2 id="八-Week-8"><a href="#八-Week-8" class="headerlink" title="八 Week 8"></a>八 Week 8</h2><h3 id="上课-ppt"><a href="#上课-ppt" class="headerlink" title="上课 ppt"></a>上课 ppt</h3><ol><li><p>cohesion:  each unit is responsible for one single logical task<br>  unit: class, method<br>  关于hashmap的疑问</p><ul><li>是否要两个元素，前面的是key，后面的事value？<br>对于zuul： 每个class都有相应的作用。game类作为main与user和terminal交流，print东西，但是room就不能print东西。</li></ul></li><li><p>2 important: coupling: loose coupling  : interface,change 1 do not need to change another.</p></li><li><p>周五上课---看的回放----11.18<br>  1.</p><pre><code> - arraylist和hashmap等等里面不能有primitive types - primitive types(int,boolean等等)不是object - 引出wrapper class(Interger,Float...) - primitive-type values wrap in objects to be stored in a **collection** - autoboxing &amp; unboxing - [int和Integer的比较](https://blog.csdn.net/chenliguan/article/details/53888018 &quot;int和Integer&quot;) - [这个讲的更详细](https://blog.csdn.net/Teacher_Lee_ZZSXT/article/details/79230501 &quot;更详细的比较&quot;)</code></pre><ol start="2"><li><p>class variables    - shared between all instances of the class.    - 属于class, 独立于instances    - 有keyword:<strong>static</strong>    - 用class的name在引用.前    - 与fields的区别?:field属于class的对象里??    - 用于:在一个class里不同的对象都需要用的变量</p></li><li><p>constant    - <strong>final</strong>    - 不能change    - 可以是public的    - static final : 经常的组合    - class constants:变量名大写    - 疑惑:final,constant和fields…static的关系    - static和final得关系    - 明确field,local variable…等等这些的关系    - constant 也可以不是final的,可以再更改它的值</p></li><li><p>class method    - static的方法都是class method    - 可直接调用    - 那存在的必要是什呢,跟其他的object method比</p><pre><code> \-\-\-不 depend于object    - limitations: instance method can call class method, but class method cannot call instance method and instance fields. 也就是说它只能用static fields,但object method 能用所有fields.</code></pre></li><li><p>outside bluej</p></li></ol><ul><li>public static void main(String[] arg)</li></ul></li></ol><h2 id="九-week9"><a href="#九-week9" class="headerlink" title="九 week9"></a>九 week9</h2><h3 id="Using-java-without-bluej"><a href="#Using-java-without-bluej" class="headerlink" title="Using java without bluej"></a>Using java without bluej</h3><ol><li>几个文件的后缀：java，class,txt..</li><li>Javac :终端命令，是java编译器的名称？</li><li>Javac 把.java变成.class</li><li>Emacs命令</li><li>java命令（后接类名无后缀）start JVM，开始执行程序</li><li>  the edit-compile-execute cycle：理解JVM    - Editor---source file---compiler(javac)---class file---virtual machine(java)</li><li>每个system都有其JVM</li><li>main method应该做什么 ---PPT里<h3 id="Fixed-sized-collections"><a href="#Fixed-sized-collections" class="headerlink" title="Fixed-sized collections"></a>Fixed-sized collections</h3></li><li>Arrays的特性<ul><li>Fixed in length 他在讲什么memory之类的东西。。。</li><li>Use a special syntax语法</li><li>它的对象没有methods，methods从其他class而来</li><li>methods都是static的</li></ul></li><li>-最大size可以？？</li><li>与List的不同之处arrays可以store对象引用和基础数据类型疑问又来了，List为何不可</li><li>例子project：weblog-analyzer</li><li>array的语法</li><li>mutator和accessor忘了</li><li>array更改element的原理</li><li>array literals</li><li>array length<h3 id="周五11-22的回看11-25"><a href="#周五11-22的回看11-25" class="headerlink" title="周五11.22的回看11.25"></a>周五11.22的回看11.25</h3></li><li>for-each loop: remove和add会导致error<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.startWith(<span class="string">&quot;t&quot;</span>))&#123;</span><br><span class="line">    list.remove(s);</span><br><span class="line">    <span class="comment">//如果remove,会skip</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>为何呢</li><li>用 for loop? ---也不好</li><li>解决办法:<strong>Iterator</strong>(用while)</li><li>Iterator用for的话,最后一个counter不需要</li><li><a href="https://blog.csdn.net/github_2011/article/details/54927531" title="总结">遍历list删除元素的总结</a></li></ul><ol start="2"><li>二维数组[][]    1. 例子:brain    - Environment里面的setup好奇怪    2. 处理图片就是处理二维数组</li></ol><h2 id="十-week10"><a href="#十-week10" class="headerlink" title="十 week10"></a>十 week10</h2><p>functional processing of collections</p><h3 id="预习PPT提纲"><a href="#预习PPT提纲" class="headerlink" title="预习PPT提纲"></a>预习PPT提纲</h3><ol><li>Lambdas</li></ol><ul><li>code can be treated as data</li><li>segments of code can be stored in variables,passed as para</li></ul><ol start="2"><li>Method vs Lambdas</li></ol><ol start="2"><li>Stream</li><li>filter，map，reduce</li><li>pipelines</li></ol><h3 id="周五的recording"><a href="#周五的recording" class="headerlink" title="周五的recording"></a>周五的recording</h3><h2 id="疑惑与计划"><a href="#疑惑与计划" class="headerlink" title="疑惑与计划"></a>疑惑与计划</h2><ol><li>auction project的源代码 看 ---11.4早于lse</li></ol><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="brain"><a href="#brain" class="headerlink" title="brain"></a>brain</h3><ol><li>cells二维数组的初始化令人迷惑</li></ol><h2 id="网址干货收藏"><a href="#网址干货收藏" class="headerlink" title="网址干货收藏"></a>网址干货收藏</h2><ol><li><a href="https://songlee24.github.io/2016/03/16/java-basic-note-1/" title="java基础知识">java基础博客</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" title="清华大学课程">清华大学计算机系课程</a></li><li><a href="https://zhuanlan.zhihu.com/p/31650418?utm_source=wechat_timeline&utm_medium=social&utm_oi=898106614555504640&from=timeline&isappinstalled=0" title="知乎AI入门">知乎人工智能入门</a></li><li><a href="https://www.zhihu.com/question/23148377/answer/863990767" title="要掌握的算法">要掌握的算法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> PPA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Arduino与Assembly</title>
      <link href="/2019/11/01/arduino/"/>
      <url>/2019/11/01/arduino/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab–汇编语言初识-amp-语法结构"><a href="#Lab–汇编语言初识-amp-语法结构" class="headerlink" title="Lab–汇编语言初识&amp;语法结构"></a>Lab–汇编语言初识&amp;语法结构</h2><span id="more"></span><h3 id="第一个程序的理解"><a href="#第一个程序的理解" class="headerlink" title="第一个程序的理解"></a>第一个程序的理解</h3><ol><li>.equ SREG,0x3f     :treat the label SREG as 0x3f</li><li>.org 0     :the start address</li><li>r16--r31,PPRB,PORTC等等在microprocessor’s CPU也就是Atmega328p里</li></ol><h2 id="lab2-portb-连led"><a href="#lab2-portb-连led" class="headerlink" title="lab2 portb 连led"></a>lab2 portb 连led</h2><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><ol><li><h4 id="SREG-status-register"><a href="#SREG-status-register" class="headerlink" title="SREG : status register"></a>SREG : status register</h4></li><li><h4 id="Rd-Destination-register-in-the-register-file"><a href="#Rd-Destination-register-in-the-register-file" class="headerlink" title="Rd : Destination register in the register file"></a>Rd : Destination register in the register file</h4></li></ol><h3 id="arduino里几个概念"><a href="#arduino里几个概念" class="headerlink" title="arduino里几个概念"></a>arduino里几个概念</h3><ol><li><h4 id="ATmega是Arduino里面的正方形芯片-microcontroller"><a href="#ATmega是Arduino里面的正方形芯片-microcontroller" class="headerlink" title="ATmega是Arduino里面的正方形芯片,microcontroller"></a>ATmega是Arduino里面的正方形芯片,microcontroller</h4></li><li><h4 id="PORTB"><a href="#PORTB" class="headerlink" title="PORTB"></a>PORTB</h4><pre><code> : an 8-bit I/O port with internal pull-up resistors, 位于: 正方形芯片的周边小点(8个:PB7:0) 它们 连接着the external digital pins</code></pre><table><thead><tr><th>Atemega pin</th><th>Nano digital pin</th></tr></thead><tbody><tr><td>PB0(在芯片的四周))</td><td>D8(在nano的两周,可连接面包板的线)</td></tr><tr><td>PB1</td><td>D9</td></tr><tr><td>….</td><td>….</td></tr></tbody></table></li><li><h4 id="digital-pin"><a href="#digital-pin" class="headerlink" title="digital pin:"></a>digital pin:</h4><pre><code> 位于nona两周: I/O interface(HIGH/LOW)</code></pre></li><li>CPU怎么链接PORTB: databus</li><li>DDRB跟PORTB,PORTC等等地位相等,都在register里,都是一个一个的寄存器,都是8bit.(each port on Atmega328 has a <strong>Data Direction Register</strong>)</li><li>DDRB和PORTB的<strong>关系</strong>:<br>  each bit of in PORTB has a corresponding input or output mode bit in DDRB.<h2 id="Lab3-portc-很好理解-读value"><a href="#Lab3-portc-很好理解-读value" class="headerlink" title="Lab3 portc 很好理解 读value"></a>Lab3 portc 很好理解 读value</h2></li></ol><h2 id="疑问疑惑"><a href="#疑问疑惑" class="headerlink" title="疑问疑惑"></a>疑问疑惑</h2><h3 id="程序内的语法"><a href="#程序内的语法" class="headerlink" title="程序内的语法:"></a>程序内的语法:</h3><ol><li>main,mainloop的意思</li><li>rjmp?</li><li>brlo <strong>lessthan</strong>? 为什么是lessthan,brlo本身不就是当lower时吗</li><li>.org 0,地址0 是跟0x06等等同一地位吗,那我在.equ里面最小的那个地址开始可以吗 --11.3<h3 id="led-on-s"><a href="#led-on-s" class="headerlink" title="led_on.s:"></a>led_on.s:</h3></li><li>SREG的作用是什么,设置为0要干什么<h3 id="第三个程序-portc-lab3"><a href="#第三个程序-portc-lab3" class="headerlink" title="第三个程序:portc(lab3)"></a>第三个程序:portc(lab3)</h3></li><li>从PINC中读取数据到PORTC,那pinc的数据从何而来?</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> Arduino </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS_note</title>
      <link href="/2019/10/31/assembly/"/>
      <url>/2019/10/31/assembly/</url>
      
        <content type="html"><![CDATA[<h1 id="五-performance-measurement-and-analysis"><a href="#五-performance-measurement-and-analysis" class="headerlink" title="五 performance measurement and analysis"></a>五 performance measurement and analysis</h1><span id="more"></span><h2 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li><p>性能equation : 1. CPU time 2. Amdahl’s law</p></li><li><p>benchmarking: </p></li><li><p>性能optimisation:<br>RISA&amp;CISC(the two main kinds of ISA design)<br>  <strong>RISC</strong>:reduced instruction set computers   <strong>shorten time by reducing clock cycle</strong></p><pre><code> simple instructions,few addressing mode</code></pre><p>  <strong>CISC</strong>:complex isc <strong>reduce the number of instructions per program</strong></p><pre><code> complex instructions,many addressing modes</code></pre><p>Branch optimisation: pipeline hazards<br>delayed branching<br>Branch prediction</p></li><li><p>disk性能: 概念: utilisation U<sub>d</sub>=r<sub>req</sub> / r<sub>srv</sub><br>FCFS: first-come,first served<br>SSTF:shortest seek time first(出现starvation的概念)<br>SCAN:not an acronym<br>C-SCAN:circular SCAN<br>LOOK/C-LOOK</p><p>注意比较各种情况下的好坏</p><h2 id="课上和课后总结理解难点"><a href="#课上和课后总结理解难点" class="headerlink" title="课上和课后总结理解难点"></a>课上和课后总结理解难点</h2></li><li><p>flushing the pipeline: conditional branck instructions</p></li><li><p>clock rate=machine cycles per second</p></li><li></li><li></li></ol><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol><li>CPU里clock cycle的理解</li><li>对于RAM里的两种memory ports: 1. 32-bits for data/address 2. 8-bit for OPCODE,<br> 是说每个横格长都是40bit吗,每一个data前面都有8bit的OPCODE吗,那怎么行得通呢</li><li>byte-addressable &amp; word-addressable:<pre><code> byte..:every byte has its own address. (word:every word) </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS</title>
      <link href="/2019/10/31/cs/"/>
      <url>/2019/10/31/cs/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h2><span id="more"></span><h1 id="二-Assembly-1"><a href="#二-Assembly-1" class="headerlink" title="二 Assembly 1"></a>二 Assembly 1</h1><ol><li><p>CPU<br> registers<br> ALU<br> control unit<br> data bus</p></li><li><p>memory organisation<br> byte-addressable/word-addressable<br> RAM chips:random access memory  lengthXwidth</p></li><li><p>I/O</p></li><li><p>Bus</p></li><li><p>Clocks<br> clock cycles<br> clock frequency(互为倒数)<br> CPU time</p></li><li><p>Interrupts</p></li><li><p>MARIE ISA</p><ul><li>load: load contents of address x into AC</li><li>store: store the contents of AC at address X</li><li>add</li><li>subt</li><li>input/output</li><li>halt: 暂停</li><li>skipcond: skip next instruction on condition</li><li>jump X: load the value of X into PC<br>那么load store jump好像没区别啊?</li></ul></li><li><p>RTL: register transfer language</p><h1 id="三-Assembly-2"><a href="#三-Assembly-2" class="headerlink" title="三 Assembly 2"></a>三 Assembly 2</h1></li><li><p>fetch-decode-execute cycle<br> PC<br> MAR<br> IR<br> PC<br> MAR<br> MBR</p></li><li><p>Interrupt processing:PPT上有两个流程图<br>  flags register<br>  maskable<br>  Nonmaskable interrupts</p></li><li><p>注意PPT里一个简单program在computer里运行的流程图!</p></li><li><p>Assemblers汇编器的工作流程:PPT!<br>  1st pass: symbol table<br>  2nd pass: the instructions are completed using the value from the <strong>symbol table</strong>.<br>  完成将汇编语言变成机器语言的过程</p></li><li><p>一个汇编语言程序:main和mainloop是address label.?? main&amp;mainloop的理解</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.equ</span> <span class="built_in">SREG</span>,<span class="number">0x3F</span></span><br><span class="line"><span class="meta">.org</span></span><br><span class="line"><span class="symbol">main:</span>   <span class="keyword">ldi</span> <span class="built_in">r16</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">out</span> <span class="built_in">SREG</span>,<span class="built_in">r16</span></span><br><span class="line"><span class="symbol">mainloop:</span> <span class="keyword">rjmp</span> mainloop</span><br></pre></td></tr></table></figure></li><li><p>indirect addressing mode时:</p></li><li><p>JnS:operates by storing the current PC value in the first address of the routine itself,then continue with the instruction following that.    Jump-and-store.<br> JumpI:return from the subroutine.</p></li><li><p>Clear</p></li><li><p> if</p></li><li><p>for/while</p></li><li><p>Procedure invocation:f()</p></li><li><p>两个samole constructs!!</p><h1 id="四-instruction-set-architectures-pipelines"><a href="#四-instruction-set-architectures-pipelines" class="headerlink" title="四 instruction set architectures/pipelines"></a>四 instruction set architectures/pipelines</h1></li><li><p>instruction formats</p><ol><li>little endian<br>big endian:正常的<br>比较: ///</li><li>how the CPU store data(3种)CPU的特殊内部存储结构<br><img src="https://wkretype.bdimg.com/retype/zoom/6a64416127d3240c8447ef13?pn=7&o=jpg_6&md5sum=1830449c7405e4dd2a4f0bb2c1b9644e&sign=df6cd0909c&png=126611-139487&jpg=805027-909057" alt="三种结构"><ol><li>stack: instructions and operands都从stack里拿,先进后出<br> stack机器用1/0operand instructions<br> Push X, Pop X<br> Add/Mult</li><li>accumulator: operand在memory中</li><li>general purpose register: 比accumulator快,instructions更长:<br> Memory-memory:<br> register-memory:至少1个operand在register.<br> load-store:无operand在memory.   </li></ol></li><li>注意0123address machimes 的code(作业中有) </li></ol></li><li><p>instruction types</p></li><li><p>addressing: where the <strong>operand</strong> is located.(a constant, a register, memory location)<br>  immediate<br>  direct<br>  indirect<br>  indexed:final=base+index</p></li><li><p>instruction level Pipelining<br> S = NKt<sub>p</sub> / (K+N-1)t<sub>p</sub><br> =K<br> pipeline hazards隐患</p></li></ol><h1 id="五-performance-measurement-and-analysis"><a href="#五-performance-measurement-and-analysis" class="headerlink" title="五 performance measurement and analysis"></a>五 performance measurement and analysis</h1><h2 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li><p>性能equation : 1. CPU time 2. Amdahl’s law</p></li><li><p>benchmarking: </p></li><li><p>性能optimisation:<br>RISA&amp;CISC(the two main kinds of ISA design)指令集类型<br>  <strong>RISC</strong>:reduced instruction set computers   <strong>shorten time by reducing clock cycle</strong></p><pre><code> simple instructions,few addressing mode</code></pre><p>  <strong>CISC</strong>:complex isc <strong>reduce the number of instructions per program</strong></p><pre><code> complex instructions,many addressing modes</code></pre><p>Branch optimisation: pipeline hazards<br>delayed branching<br>Branch prediction</p></li><li><p>disk性能: 概念: utilisation U<sub>d</sub>=r<sub>req</sub> / r<sub>srv</sub><br>FCFS: first-come,first served<br>SSTF:shortest seek time first(出现starvation的概念)<br>SCAN:not an acronym<br>C-SCAN:circular SCAN<br>LOOK/C-LOOK</p><p>注意比较各种情况下的好坏</p><h2 id="课上和课后总结理解难点"><a href="#课上和课后总结理解难点" class="headerlink" title="课上和课后总结理解难点"></a>课上和课后总结理解难点</h2></li></ol><h1 id="七-二进制①-JoshM"><a href="#七-二进制①-JoshM" class="headerlink" title="七 二进制① JoshM"></a>七 二进制① JoshM</h1><h2 id="PPT提纲-1"><a href="#PPT提纲-1" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li>negative numbers in binary: 几个概念: unsighed binary<br> formats:     1. signed magnitude  : MSB(the most significant bit) is a sign bit---0+&amp;1-  源码<br>   0的源码有两种:00000000&amp;10000000,0的补码只有:00000000.    2. One’s complement. 反码    3. Two’s complement  补码(对于正数补码相同)<pre><code> [X]&lt;sub&gt;补&lt;/sub&gt; = X + M 这个M是mod M,模数M根据机器数的位数而定,位数为81则M=2&lt;sup&gt;8&lt;/sup&gt;    </code></pre> 对于负数:<br> 1.真值:将各位变反,then最低位+1<br> 2.源码: 符号位不变,其余各位变反then最低位+1<br>   11111111是-1的补码,10000000是-128的补码.0的补码只有一个:00000000.</li></ol><pre><code>4. 注意优缺点!!!(PPT17)5. 各方式表示的范围(8bits)    unsigned binary: 0 \-\-\-255    源码:-127(11111111)\-\-\-+127(01111111)    反码:-127(11111111)\-\-\-+127(01111111)    补码:-128(10000000)\-\-\-+127(01111111)</code></pre><h2 id="二进制运算法则"><a href="#二进制运算法则" class="headerlink" title="二进制运算法则"></a>二进制运算法则</h2><pre><code>1. 10转2:减权定位         除基取余(直到商为0):从最下面的余数开始!   小数10转2:减权定位            乘基取整:从最上面的余数开始2. 2转10: 按权相加(小数2转10同)3. 十转八:除基取余比较简单</code></pre><h1 id="八-binary-②"><a href="#八-binary-②" class="headerlink" title="八 binary ②"></a>八 binary ②</h1><h2 id="上课-PPT"><a href="#上课-PPT" class="headerlink" title="上课 PPT"></a>上课 PPT</h2><ol><li><p>unsigned: </p><ol><li>unsigned addtion---<strong>overflow</strong><ul><li>是一个圈,从111再加就是000了</li><li>incrementinf by one <strong>?!?!</strong> 那几句话没理解PPT第5页</li></ul></li><li>subtraction (注意借位,需要练习)<ul><li>first check the minus…???</li></ul></li><li>multipication<ul><li>感觉像分列式,分几个part乘,最后加一起.</li></ul></li><li>division: 很像十进制的除法方式.</li></ol></li><li><p>signed magnitude arithmetric:</p><ol><li>加</li><li>check the <strong>sign</strong> firstly</li><li>如果<strong>符号不同</strong>: 比较绝对值大小------用大的减小的------用绝对值大的数的sign.</li><li>overflow 那个圈没理解</li><li>减</li><li>x-y: - y如果是<code>负</code>------变成<strong>x+(-y)</strong><pre><code> - y是`正`且x是`负`\-\-\-\-变成*-(-x+y)** - y是`正`且x是`正`\-\-\-\-变成**(-y)+x** - 但我第一次做作业,全错...</code></pre></li></ol></li><li><p>one’s complement arithmetic</p><ol><li>反码,加完多一位,再加(多么神奇…需要记忆以及与其它区分)</li></ol></li><li><p>two’s complement arithmetic</p><ol><li>忽略加完后的第一位.</li><li><strong>detecting overflow</strong><br> 新概念:carry和borrow<br> carry-in = carry-out------no overflow<br> but这个是怎么计算的???</li></ol></li><li><p>Error detection and correction:</p><ol><li>hamming distance:不同的位数</li><li>parity bit :要sufficient才能correct error,</li><li>code word : 存在的必要是什么</li><li>是在bus上传递数据用的吗?那学过的存储模式pocode+address跟这个是什么关系?</li></ol></li></ol><h2 id="重难点解析"><a href="#重难点解析" class="headerlink" title="重难点解析"></a>重难点解析</h2><ol><li>三个overflow的图一定要好好理解.</li><li><del>真值,补码,反码,源码之间的变化!!</del></li><li>补码overflow detect</li><li>sign的减法和乘除</li></ol><h1 id="九-floating-point-binary"><a href="#九-floating-point-binary" class="headerlink" title="九 floating-point binary"></a>九 floating-point binary</h1><h2 id="预习-回看"><a href="#预习-回看" class="headerlink" title="预习+回看"></a>预习+回看</h2><ol><li></li></ol><h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><ol><li>Assembly 2 里 JnS </li><li>那么load store jump好像没区别啊? ---11.6</li><li>对于Assembly1作业中的第3题.醍醐灌顶:<br> A 1-bit address can address two words (0, 1).<br> A 2-bit address can address four words (00, 01, 10, 11).<br> A 3-bit address can address eight words (000, 001, 010, 011, 100, 101, 110, 111).<br> but<img src="https://www.coursehero.com/doc-asset/bg/d6bc39dcf48520faf6897593e05282dad7676ae0/splits/v9.frq.clean/split-1-page-1-html-bg.jpg" alt="答案不一样"></li><li><strong>八---二进制2</strong>需要加强理解和动手去做的:1. <del>三种表示二进制数的转化自己去操作</del>. 2. 进制直接每种情况的转化去运算.   ---11.13</li><li><del>对于加了sign的源码,为什么不是额外加一位呢,不影响原本的真值吗?</del>  ---11.13八课上</li><li>对于补码的运算,手机里的照片 理解和解惑. ---11.13八课上</li><li>---11.13晚自习 二进制转八进制,万一位数除不尽3怎么办?</li></ol><h1 id="作业tutorial-的总结"><a href="#作业tutorial-的总结" class="headerlink" title="作业tutorial 的总结"></a>作业tutorial 的总结</h1><ol><li>---11.13晚,week7,binary1.<ul><li>减权定位终于知道了怎么做</li><li>小数10转2,乘积取整还不会</li><li>4个表示方法的范围需要记住</li></ul></li><li>---11.13晚,week8,binary2.<ul><li>unsigned减法必须是正数,因为它无负数</li><li>unsigned除法中除不尽就用reminder余数</li><li>signed的减法中,1110111-0010001为何overflow呢</li><li>0010101-0110011算不对啊,按照(-y)+x的规则啊</li><li>signed的乘除法,全错.(我原本的方法是忽略头一位,再在最后加上头一位)</li><li>反码的加:01101+00100 为何overflow</li><li>补码的加: carry-in和carry-out和overflow detected 是什么</li><li>一定要记住正数的反码和补码都是它,运算的时候一定要仔细1+1变为0</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MatLab</title>
      <link href="/2019/10/30/matlab/"/>
      <url>/2019/10/30/matlab/</url>
      
        <content type="html"><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><span id="more"></span><h2 id="创建x轴的数组"><a href="#创建x轴的数组" class="headerlink" title="创建x轴的数组"></a>创建x轴的数组</h2><p>s = linspace()<br>与直接[ : : ]</p><h2 id="绘制函数图象时"><a href="#绘制函数图象时" class="headerlink" title="绘制函数图象时"></a>绘制函数图象时</h2><p>syms变量–fplot<br>与直接设置x和y对应数组–plot</p><h2 id="设置坐标轴范围时"><a href="#设置坐标轴范围时" class="headerlink" title="设置坐标轴范围时"></a>设置坐标轴范围时</h2><p>xlim(xmin ymin)和ylim()<br>与aixs[xmin xmax ymin ymax]<br>是一个道理</p><h2 id="绘制图像的几个函数"><a href="#绘制图像的几个函数" class="headerlink" title="绘制图像的几个函数"></a>绘制图像的几个函数</h2><ul><li>plot()</li><li>line():画直线型</li><li>polar():极坐标下绘曲线<h2 id="求函数一段范围内的极值"><a href="#求函数一段范围内的极值" class="headerlink" title="求函数一段范围内的极值"></a>求函数一段范围内的极值</h2></li><li>lab7</li><li>感觉有几种方法</li><li>画分段函数的几种方法:正常拆分开;@x</li></ul><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="创建矩阵的方法"><a href="#创建矩阵的方法" class="headerlink" title="创建矩阵的方法"></a>创建矩阵的方法</h2><ol><li>B=a:h:b;  其中a,b代表一维矩阵（向量）的区间，h为步宽</li><li>zeros(行数,列数).ones,rand同.</li><li></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> MatLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MatLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMTE_note</title>
      <link href="/2019/10/30/cmte-s-note/"/>
      <url>/2019/10/30/cmte-s-note/</url>
      
        <content type="html"><![CDATA[<h1 id="四-Vector-Algebra"><a href="#四-Vector-Algebra" class="headerlink" title="四 Vector  Algebra"></a>四 Vector  Algebra</h1><h2 id="空间直线-空间平面"><a href="#空间直线-空间平面" class="headerlink" title="空间直线,空间平面"></a>空间直线,空间平面</h2><span id="more"></span><h3 id="空间直线几个形式的方程-空间平面的方程"><a href="#空间直线几个形式的方程-空间平面的方程" class="headerlink" title="空间直线几个形式的方程,空间平面的方程."></a>空间直线几个形式的方程,空间平面的方程.</h3><p>Ax +By +Cz + D = 0</p><p>其中n = (A, B, C)是平面的法向量，D是将平面平移到坐标原点所需距离（所以D=0时，平面过原点）</p><h3 id="空间两直线的距离-点到平面以及到直线的距离-公式"><a href="#空间两直线的距离-点到平面以及到直线的距离-公式" class="headerlink" title="空间两直线的距离,点到平面以及到直线的距离 公式"></a>空间两直线的距离,点到平面以及到直线的距离 公式</h3><p>(联立方程)<br><img src="https://pic002.cnblogs.com/img/zdd/201007/2010071013450338.jpg" alt="点到平面" title="公式"></p><h2 id="已知两平面方程求交点坐标"><a href="#已知两平面方程求交点坐标" class="headerlink" title="已知两平面方程求交点坐标"></a>已知两平面方程求交点坐标</h2><h2 id="物理学中的力矩和功"><a href="#物理学中的力矩和功" class="headerlink" title="物理学中的力矩和功"></a>物理学中的力矩和功</h2><p>机械功:work<br>力矩:moment of force<br>     the tendency of a force to make an object <strong>rotate</strong> .<br>两个物理意义不同,符号相同.牛顿-米.<br>力矩<em>t=rXF</em>, 这个r不是功里面那样的在F方向的位移,而是从转轴到施力点的位移矢量.</p><h1 id="五-Matrix-Algebra"><a href="#五-Matrix-Algebra" class="headerlink" title="五 Matrix Algebra"></a>五 Matrix Algebra</h1><h2 id="3阶矩阵运算易错的是"><a href="#3阶矩阵运算易错的是" class="headerlink" title="3阶矩阵运算易错的是:"></a>3阶矩阵运算易错的是:</h2><p>第二列的余子式中两列的顺序: 是从左到右 不是从右到左!</p><h2 id="课件提纲-amp-概念"><a href="#课件提纲-amp-概念" class="headerlink" title="课件提纲&amp;概念"></a>课件提纲&amp;概念</h2><ol><li><p>矩阵---多元方程组</p></li><li><p>changes of  axes 旋转----结合预科课件: 逆时针顺时针</p></li><li><h3 id="几个矩阵和概念"><a href="#几个矩阵和概念" class="headerlink" title="几个矩阵和概念"></a>几个矩阵和概念</h3><ul><li><p>square m,column/row vector,diagonal m,unit/identity ma,symmetric m,upper-/lower-triangular m,diagonal对角矩阵,scalar数量矩阵(主对角元全相等)</p></li><li><p>singular:奇异(行列式为0)</p></li><li><p>trace: 迹sum of <strong>leading diagonal</strong>主对角线(左上右下)</p></li><li><p>A<sup>T</sup>: 手心手背 转置矩阵</p><pre><code>   行列式和转置行列式**相等**</code></pre></li><li><p>minor:余子式,cofactor 代数余子式多一个-1的次方</p></li><li><p>adjoint:伴随矩阵 <em><strong>注意特性和公式</strong></em> 代数余子式组成</p></li><li><h4 id="inverse-matrix-逆矩阵"><a href="#inverse-matrix-逆矩阵" class="headerlink" title="inverse matrix: 逆矩阵"></a>inverse matrix: 逆矩阵</h4></li><li><h4 id="Cramer’s-rule卡姆拉法则"><a href="#Cramer’s-rule卡姆拉法则" class="headerlink" title="Cramer’s rule卡姆拉法则 :"></a>Cramer’s rule卡姆拉法则 :</h4></li><li><h4 id="Gaussian-elimination-见矩阵运算板块高斯消元法"><a href="#Gaussian-elimination-见矩阵运算板块高斯消元法" class="headerlink" title="Gaussian elimination: 见矩阵运算板块高斯消元法"></a>Gaussian elimination: 见矩阵运算板块<em>高斯消元法</em></h4></li><li><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref<br></h4><pre><code>row echelon form阶梯型矩阵: 下阶梯,leadingentry是1.rref行简化阶梯形矩阵:在ref基上&lt;p&gt;非零首元所在的列/p&lt;&gt;除了非零首元外，其余元素全为0.每个首项是1.每个矩阵,ref不唯一,**rref唯一**.</code></pre></li><li><p>independent &amp; dependent vectors线性相关无关</p><pre><code>linear combination of vectors线性组合(是一个向量而不是关系)注意根据定义,线性相关是n个向量组成的组,至少其余n-个可以表示一个</code></pre></li><li><p>Rank 秩 :最大线性无关的向量的个数  在ref形势下含非0的行数</p></li><li><p><strong>eigenvalue</strong>特征值</p><pre><code> - characteristic polynomial(PPT72页),特征多项式characteristic equation of A特征方程 - eigenvector特征向量 -</code></pre></li></ul></li><li><p> 注意<strong>矩阵×标量</strong>与行列式×标量的区别: 矩阵式乘每个元素,行列式乘一行.</p></li><li><h3 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结:"></a>公式总结:</h3><ul><li>(AB)<sup>T</sup> = B<sup>T</sup>A<sup>T</sup> &amp; adj(AB) = adj(B)adj(A)</li><li>eigenvalue的性质(PPT末尾)</li><li><code>AA*=A*A=|A|E</code>  (*伴随矩阵)</li><li><pre><code>  A&lt;sup&gt;-1&lt;/sup&gt;=(1/|A|)*A*(可轻易有上一行结合AA&lt;sup&gt;-1&lt;/sup&gt;=E推出)</code></pre></li><li> |A*|=|A|<sup>n-1</sup>  (可轻易有上上一行推出)</li></ul></li><li><h3 id="矩阵运算-化简得基本步骤"><a href="#矩阵运算-化简得基本步骤" class="headerlink" title="矩阵运算,化简得基本步骤"></a>矩阵运算,化简得基本步骤</h3><ul><li>Gaussian elimination<em>高斯消元法</em>:<ol><li>最左上角变为1,依次用第一行的减-把剩下行的第一个数变0,这是第一遍,</li><li>第二遍从第二行开始,把第二行第二列变1,依次用第二行减-使下面的行的第二个数变0,</li><li>直到成为上三角.<pre><code>补充:线性方程组的**初等变换**:      1. 交换两个方程的位置(就好比与换矩阵的行!理解了)      2. 一个方程两端同乘不为0的数      3. 同乘不为0的数后加到另一方程去</code></pre></li></ol></li><li>转化成ref(下阶梯):PPT第58页<pre><code>1. pivot:第一个第一列不为0的行,提到第一行2. 依次把下面行的第一列第一行变为03. 去掉第一列,从新开始找pivot4. 在此基础上转化成**rref**: 找到非0首元,把其上的全变为0</code></pre></li><li>find matrix <strong>rank</strong>:<pre><code>1. 矩阵的ref形式里含有非0行的数量 = 矩阵中independent vector(每一行就是一个vector)</code></pre></li><li>eigenvalue: AX = aX<pre><code> - 已知A可求a - 已知A和a可求X(eigenvector)</code></pre></li><li>矩阵加减:要同规模(与行列式不同,矩阵是每排,行列式不同的那一排(其余的每一排要对应相等))</li><li>矩阵乘法:好比说AB,要求是A的列数等于B的行数, 那么得到的矩阵规模是A的行数B的列数<h2 id="二级结论"><a href="#二级结论" class="headerlink" title="二级结论"></a>二级结论</h2></li><li><h3 id="上三角行列式"><a href="#上三角行列式" class="headerlink" title="上三角行列式"></a>上三角行列式</h3><pre><code>    的值D = 对角线元素乘积</code></pre></li><li><h3 id="n阶行列式的性质"><a href="#n阶行列式的性质" class="headerlink" title="n阶行列式的性质"></a>n阶行列式的性质</h3><pre><code>    1. 行列式等于它的转置行列式    2. 互换行列式中的两行/列,行列式变号(**行列式是一个值数,与矩阵不同**),那矩阵换行呢**??**    3. 行列式有两行/列对应相等或者对应成比例,行列式 = 0或者行列式有一行全为0,行列式也为0    4. 行列式乘一个数,就乘一行,跟矩阵一样??    5. 最重要的来了: 把某一行/列元素的k倍加到另一行/列,行列式的值不变不变不变!    6. 可以用上述这些进行行列式的计算</code></pre></li><li><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><pre><code>    1. 一个特殊行列式: 范德蒙Vandermonde</code></pre></li><li><pre><code>  可交换矩阵commutable: 数量矩阵与同阶任何矩阵,A与单位阵,对角阵与对角阵</code></pre></li><li><pre><code>  方阵的幂</code></pre></li><li>矩阵的初等变换: 极其类似行列式的初等变换</li></ul></li></ol><h2 id="疑问疑惑不理解"><a href="#疑问疑惑不理解" class="headerlink" title="疑问疑惑不理解"></a>疑问疑惑不理解</h2><ol><li>矩阵这么乘啊加啊,它行列式的值不会变吗,为什么可以这样</li><li>转化成ref</li><li>怎么用矩阵解三元一次方程(就像解eigenvector)</li><li>我记得我总结过行列式与矩阵的不同??</li><li>记得PPT最后的几个性质 PPT的例题----可以lab时候做---<em>于10.31</em></li></ol><h2 id="难点和做题总结"><a href="#难点和做题总结" class="headerlink" title="难点和做题总结"></a>难点和做题总结</h2><ol><li>求特征向量的时候,就设xyz根据向量积的基本法则求,它们积是0.</li><li></li></ol><h1 id="七-函数的极限"><a href="#七-函数的极限" class="headerlink" title="七 函数的极限"></a>七 函数的极限</h1><h2 id="PPT中的基本英文的概念"><a href="#PPT中的基本英文的概念" class="headerlink" title="PPT中的基本英文的概念:"></a>PPT中的基本英文的概念:</h2><ol><li>夹逼定理:sandwich theorem</li><li>precose(formal) definition of Limit</li><li>one-side limut</li><li>continuity at a point</li></ol><h1 id="八-导数-11-14上课"><a href="#八-导数-11-14上课" class="headerlink" title="八 导数 ---11.14上课"></a>八 导数 ---11.14上课</h1><h2 id="ppt与课本"><a href="#ppt与课本" class="headerlink" title="ppt与课本"></a>ppt与课本</h2><ol><li>课本书签中左右导数的具体计算过程</li><li>注意题型大部分有可能是物理应用</li><li>复习去年学的导数那一章，注意肯定有很多题型（比如说微分什么的计算我记得）</li><li>----11.18上matlab: 搞清楚几种极值,什么<strong>local maximum,absolute minimum</strong>对应的中文概念和此时函数的导数二次导数等等的特性.总结出来!</li><li>在本周quiz中,出现了一个我竟然忘记的东西!! 那就是 函数此点可导的条件有两个,<strong>1此点连续,2左导数=右导数!!!!</strong></li></ol><h1 id="九-微分方程"><a href="#九-微分方程" class="headerlink" title="九 微分方程"></a>九 微分方程</h1><h2 id="ppt提纲"><a href="#ppt提纲" class="headerlink" title="ppt提纲"></a>ppt提纲</h2><ol><li>first-order initial value problem</li><li>slope fields</li><li><strong>[Euler’s method]</strong>(<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95">https://zh.wikipedia.org/wiki/欧拉方法</a> “欧拉法”)</li><li>linear equation</li><li>autonomous equation</li></ol><ul><li>equilibrium values or rest points</li></ul><ol start="6"><li>phase line</li><li>systems of equations</li></ol><ul><li>autonomous</li></ul><ol start="8"><li>phase planes</li></ol><ul><li>trajectory</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
          <category> KCL </category>
          
          <category> CMTE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间向量 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
