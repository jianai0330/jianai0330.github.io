<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ajn</title>
  
  <subtitle>Cohen</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jianai0330.github.io/"/>
  <updated>2019-12-03T22:10:38.453Z</updated>
  <id>https://jianai0330.github.io/</id>
  
  <author>
    <name>A jian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日总结</title>
    <link href="https://jianai0330.github.io/2019/11/25/mei-ri-zong-jie/"/>
    <id>https://jianai0330.github.io/2019/11/25/mei-ri-zong-jie/</id>
    <published>2019-11-25T16:44:57.000Z</published>
    <updated>2019-12-03T22:10:38.453Z</updated>
    
    <content type="html"><![CDATA[<p>一切随缘好了,开心和积极向上是最重要的</p><a id="more"></a><h1 id="Temple-周-week"><a href="#Temple-周-week" class="headerlink" title="Temple 周  week"></a>Temple 周  week</h1><h2 id="吃了什么"><a href="#吃了什么" class="headerlink" title="吃了什么"></a>吃了什么</h2><ul><li>0.1: 一个cheeseroll 一个面包 一碗饭 若干水果</li><li>0.2:</li><li>0.3:</li></ul><hr><h2 id="今天的运动"><a href="#今天的运动" class="headerlink" title="今天的运动"></a>今天的运动</h2><h2 id="5440步"><a href="#5440步" class="headerlink" title="5440步"></a>5440步</h2><h2 id="今天的支出和收入"><a href="#今天的支出和收入" class="headerlink" title="今天的支出和收入"></a>今天的支出和收入</h2><ul><li>支出: 12.2</li><li>收入: 0</li></ul><hr><h2 id="今天的学习内容总结"><a href="#今天的学习内容总结" class="headerlink" title="今天的学习内容总结"></a>今天的学习内容总结</h2><ul><li>1.1:预习了三课cs</li><li>1.2:</li><li>1.3:</li><li>1.4:</li></ul><hr><h2 id="所以收获了什么呢"><a href="#所以收获了什么呢" class="headerlink" title="所以收获了什么呢"></a>所以收获了什么呢</h2><ul><li>2.1: 去了预科lecture介绍自己</li><li>2.2:</li><li>2.3:</li><li>2.3:</li></ul><hr><h2 id="遗留的疑问是"><a href="#遗留的疑问是" class="headerlink" title="遗留的疑问是?"></a>遗留的疑问是?</h2><ul><li>3.1:</li><li>3.2:</li><li>3.3:</li><li>3.4:</li></ul><hr><h2 id="明天的计划是什么呢"><a href="#明天的计划是什么呢" class="headerlink" title="明天的计划是什么呢"></a>明天的计划是什么呢</h2><ul><li>4.1:</li><li>4.2:</li><li>4.3:</li><li>4.4:</li></ul><hr><h2 id="心情好吗-有激情吗"><a href="#心情好吗-有激情吗" class="headerlink" title="心情好吗,有激情吗?"></a>心情好吗,有激情吗?</h2><h1 id="11-26-周二-week10"><a href="#11-26-周二-week10" class="headerlink" title="11.26 周二  week10"></a>11.26 周二  week10</h1><h2 id="吃了什么-1"><a href="#吃了什么-1" class="headerlink" title="吃了什么"></a>吃了什么</h2><ul><li>0.1:spicy chicken</li><li>0.2:些许圣女果</li><li>0.3:</li></ul><hr><h2 id="今天的运动-1"><a href="#今天的运动-1" class="headerlink" title="今天的运动"></a>今天的运动</h2><h2 id="11128步"><a href="#11128步" class="headerlink" title="11128步"></a>11128步</h2><h2 id="今天的支出和收入-1"><a href="#今天的支出和收入-1" class="headerlink" title="今天的支出和收入"></a>今天的支出和收入</h2><ul><li>支出: 差不多7</li><li>收入: 0</li></ul><hr><h2 id="今天的学习内容总结-1"><a href="#今天的学习内容总结-1" class="headerlink" title="今天的学习内容总结"></a>今天的学习内容总结</h2><ul><li>1.1: ppa完成了base task</li><li>1.2: 天,我这效率</li><li>1.3: 看了frozen2</li><li>1.4:</li></ul><hr><h2 id="所以收获了什么呢-1"><a href="#所以收获了什么呢-1" class="headerlink" title="所以收获了什么呢"></a>所以收获了什么呢</h2><ul><li>2.1: 还好吧,</li><li>2.2:</li><li>2.3:</li><li>2.3:</li></ul><hr><h2 id="遗留的疑问是-1"><a href="#遗留的疑问是-1" class="headerlink" title="遗留的疑问是?"></a>遗留的疑问是?</h2><ul><li>3.1:</li><li>3.2:</li><li>3.3:</li><li>3.4:</li></ul><hr><h2 id="明天的计划是什么呢-1"><a href="#明天的计划是什么呢-1" class="headerlink" title="明天的计划是什么呢"></a>明天的计划是什么呢</h2><ul><li>4.1: ppa昨日内容</li><li>4.2: 给我写REPORT!带去工作的地方,注意格式</li><li>4.3: cs两周内容</li><li>4.4: 周四记得去学校复印证件</li><li>4.5: 查看oyster 18+</li></ul><hr><h2 id="心情好吗-有激情吗-1"><a href="#心情好吗-有激情吗-1" class="headerlink" title="心情好吗,有激情吗?"></a>心情好吗,有激情吗?</h2><ul><li>按照1---10打分</li><li>5, ppa得努力啊!高分啊!</li></ul><h1 id="11-25-周一-week10"><a href="#11-25-周一-week10" class="headerlink" title="11.25 周一 week10"></a>11.25 周一 week10</h1><h2 id="吃了什么-2"><a href="#吃了什么-2" class="headerlink" title="吃了什么"></a>吃了什么</h2><ul><li>0.1:无</li><li>0.2:两个cheese roll,一袋李子</li><li>0.3:一个鸡蛋,半杯麦片,圣女果一袋</li></ul><hr><h2 id="今天的运动-2"><a href="#今天的运动-2" class="headerlink" title="今天的运动"></a>今天的运动</h2><h2 id="没有…除了去Sainsbury…"><a href="#没有…除了去Sainsbury…" class="headerlink" title="没有…除了去Sainsbury…"></a>没有…除了去Sainsbury…</h2><h2 id="今天的支出和收入-2"><a href="#今天的支出和收入-2" class="headerlink" title="今天的支出和收入"></a>今天的支出和收入</h2><ul><li>支出: 4.9</li><li>收入: 0</li></ul><hr><h2 id="今天的学习内容总结-2"><a href="#今天的学习内容总结-2" class="headerlink" title="今天的学习内容总结"></a>今天的学习内容总结</h2><ul><li>1.1: 把cmte本周的所有任务完成了</li><li>1.2: ppa做了很多,好的开展</li><li>1.3:</li><li>1.4:</li></ul><hr><h2 id="所以收获了什么呢-2"><a href="#所以收获了什么呢-2" class="headerlink" title="所以收获了什么呢"></a>所以收获了什么呢</h2><ul><li>2.1: 收获了快乐??还算不错</li><li>2.2:</li><li>2.3:</li><li>2.3:</li></ul><hr><h2 id="遗留的疑问是-2"><a href="#遗留的疑问是-2" class="headerlink" title="遗留的疑问是?"></a>遗留的疑问是?</h2><ul><li>3.1:</li><li>3.2:</li><li>3.3:</li><li>3.4:</li></ul><hr><h2 id="明天的计划是什么呢-周二"><a href="#明天的计划是什么呢-周二" class="headerlink" title="明天的计划是什么呢 周二"></a>明天的计划是什么呢 周二</h2><ul><li>4.1: 12点起床洗澡,用黄盒子带圣女果</li><li>4.2: 回看和作业 CS的</li><li>4.3: 看电影和吃东西 :给我把握好</li><li>4.4: ppa report要开始写了!</li><li>4.5: 看电影完适当购物: 腌莴笋的用品!!!</li><li>4.6: 睡前看PPA的回放</li><li>4.7:cscscs!!!</li></ul><hr><h2 id="心情好吗-有激情吗-2"><a href="#心情好吗-有激情吗-2" class="headerlink" title="心情好吗,有激情吗?"></a>心情好吗,有激情吗?</h2><ul><li>按照1---10打分</li><li>7 没有食欲,学习欲望一般 ---17:18</li><li>7 睡前</li></ul><hr><h1 id="近期待办的事务"><a href="#近期待办的事务" class="headerlink" title="近期待办的事务"></a>近期待办的事务</h1><ul><li>5.1: 黑五买两件大衣!</li><li>5.2:</li><li>5.3:</li></ul><hr><h1 id="Temple-周-week-1"><a href="#Temple-周-week-1" class="headerlink" title="Temple 周  week"></a>Temple 周  week</h1><h2 id="吃了什么-3"><a href="#吃了什么-3" class="headerlink" title="吃了什么"></a>吃了什么</h2><ul><li>0.1:</li><li>0.2:</li><li>0.3:</li></ul><hr><h2 id="今天的运动-3"><a href="#今天的运动-3" class="headerlink" title="今天的运动"></a>今天的运动</h2><hr><h2 id="今天的支出和收入-3"><a href="#今天的支出和收入-3" class="headerlink" title="今天的支出和收入"></a>今天的支出和收入</h2><ul><li>支出:</li><li>收入:</li></ul><hr><h2 id="今天的学习内容总结-3"><a href="#今天的学习内容总结-3" class="headerlink" title="今天的学习内容总结"></a>今天的学习内容总结</h2><ul><li>1.1:</li><li>1.2:</li><li>1.3:</li><li>1.4:</li></ul><hr><h2 id="所以收获了什么呢-3"><a href="#所以收获了什么呢-3" class="headerlink" title="所以收获了什么呢"></a>所以收获了什么呢</h2><ul><li>2.1:</li><li>2.2:</li><li>2.3:</li><li>2.3:</li></ul><hr><h2 id="遗留的疑问是-3"><a href="#遗留的疑问是-3" class="headerlink" title="遗留的疑问是?"></a>遗留的疑问是?</h2><ul><li>3.1:</li><li>3.2:</li><li>3.3:</li><li>3.4:</li></ul><hr><h2 id="明天的计划是什么呢-2"><a href="#明天的计划是什么呢-2" class="headerlink" title="明天的计划是什么呢"></a>明天的计划是什么呢</h2><ul><li>4.1:</li><li>4.2:</li><li>4.3:</li><li>4.4:</li></ul><hr><h2 id="心情好吗-有激情吗-3"><a href="#心情好吗-有激情吗-3" class="headerlink" title="心情好吗,有激情吗?"></a>心情好吗,有激情吗?</h2><ul><li>按照1---10打分</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切随缘好了,开心和积极向上是最重要的&lt;/p&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="life" scheme="https://jianai0330.github.io/categories/2019/life/"/>
    
      <category term="everynight" scheme="https://jianai0330.github.io/categories/2019/life/everynight/"/>
    
    
  </entry>
  
  <entry>
    <title>FC</title>
    <link href="https://jianai0330.github.io/2019/11/13/fc/"/>
    <id>https://jianai0330.github.io/2019/11/13/fc/</id>
    <published>2019-11-13T14:15:59.000Z</published>
    <updated>2019-12-04T21:00:56.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六-graphs"><a href="#六-graphs" class="headerlink" title="六 graphs"></a>六 graphs</h1><a id="more"></a><h2 id="PPT提纲-11-13-拖延症…"><a href="#PPT提纲-11-13-拖延症…" class="headerlink" title="PPT提纲 ---11.13 拖延症…"></a>PPT提纲 ---11.13 拖延症…</h2><ol><li>graph的种类:<ul><li>simple(e.g.Niche overlap graphs in ecology): --------没方向undirected,没multiple edges,没loop edges</li><li>multigraph(e.g.Road networks):----------------没方向undirected,有multiple edges,有loop</li><li>directed graph(e.g.representing binary relations前几章学的):--有方向directed,没multiple edges,有loop</li><li>!开头比较三者的表格理解!</li></ul></li><li>undirected graphs概念<br> 一些概念: 两个点相连 它们adjacent,此线edge incident with 两个点<br> degree:此点含线edge的条数<br>  由此有:isolated孤家寡人 &amp; pendant(一条,degree 1,垂饰很好理解)<br> Handshaking theorem:<strong>edge的条数=点们的degree的和/2</strong></li><li>directed graph的一些概念(它有方向!)<br> 起点is the initial or start vertex of 线,终点 is the terminal or end vertex of 线<br> in-degree:此点含作为终点的线的条数<br> out-degree:此点含作为起点的线的条数(注意loop一个圈的话是in和out都要算进去的)<br> 公式:线的条数=in/out</li><li>adjacency matrix</li><li>Path<ul><li>length:所包含edge的条数</li><li>Simple:doesnt contain the same <strong>edge</strong> twice</li><li>Hamiltonian path: 在simple的基础上passing every <strong>vertex 一次</strong></li></ul></li><li>cycle(可与path类比)</li><li>complete graph (n-clique)   n-cycle</li><li>subgraph</li><li>connected graphs   , conneed component</li><li>isomorphic同构 if isomorphism(保持结构的双射)  , invariant</li></ol><h1 id="七-tree"><a href="#七-tree" class="headerlink" title="七 tree"></a>七 tree</h1><h2 id="PPT提纲预习-11-13"><a href="#PPT提纲预习-11-13" class="headerlink" title="PPT提纲预习 ----11.13"></a>PPT提纲<code>预习</code> ----11.13</h2><ol><li>定义: vertices,root,edge</li><li>edge是一条线,vertix是点 ?</li><li>rooted tree</li><li>parent,child,siblings. leaf,internal(vertices with at least one child)<br>ancestors(以上线上的所有),descendants</li><li>应用: binanry search trees &amp; decomposition trees</li><li>概念:level,height,balanced,subtree</li><li>m-ary tree, full m-ary tree,full binary tree</li><li>有几个二级结论:<ul><li>对于full binary tree :n internal vertices ------<strong>2n+1</strong> vertices</li><li>对于full m-ary  tree: n internal vertices ------<strong>m*n+1</strong> vertices</li></ul></li><li>逻辑式可以用二叉树</li><li>binary search trees : sorting linearly ordered list</li><li>tree traversal: preoder,inorder,postorder</li></ol><h2 id="课上-提纲"><a href="#课上-提纲" class="headerlink" title="课上 | 提纲"></a>课上 | 提纲</h2><ol><li>概念和定义<br> 什么是TREE<ul><li><strong>simple</strong> graph with no simple cycles(有cycle就不是tree,必须要是connected的)</li><li>a unique simple path between任意两点</li><li>如果加一条edge，会产生cycle</li><li>如果减一条edge，会disconnected</li></ul></li></ol><ol start="2"><li><p>rooted tree</p><ul><li><p>特性是其中一个vertex被当作root（放在top）</p></li><li><p>两个rooted trees are <strong>isomorphic</strong> -----bijection</p><ul><li>root to rooted</li><li>edges to edges</li><li>non-edges to non-edges<br> ？</li></ul></li><li><p>basic terminology</p><ul><li>特别注意internal vertices 和 leaves，一个有children，一个没有children。</li><li>leaves没children，是垂饰in graph？</li><li>level： 从root的0开始</li><li>height： 也要从0开始算！ height=层数-1！</li><li>balanced的概念理解过来就是每一个分支的长都要等于height或者height-1。</li><li></li></ul></li></ul></li><li><p>几个特殊的tree和二级结论：</p><ul><li><p>m-ary treeM</p><ul><li>每一个internal的children不超过m</li></ul></li><li><p>full m-ary tree</p><ul><li>每一个internal的children等于m</li><li>不明白 这怎么可能？！</li></ul></li><li><p>full binary tree</p><ul><li>每一个internal 有2children</li></ul></li><li><p>m*n+1</p></li><li><p>logic formula</p></li></ul></li><li><p>BST</p><ul><li>注意linear order, partial order的概念</li><li>lexicographical order</li></ul></li><li><p>traversal遍历 三种</p></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>graph和tree里edgetoedge和nonedge到底是什么意思 怎么用</li></ol><h1 id="八-finite-automata-11-17周日"><a href="#八-finite-automata-11-17周日" class="headerlink" title="八 finite automata---11.17周日"></a>八 finite automata---11.17周日</h1><p>finite automata : finite-state machines</p><ol><li>preliminaries:alphabets and words<ul><li>length</li><li>concatenation</li><li>prefix,suffix</li><li>language</li></ul></li></ol><p>2.finite automation:a theoretical model for programs using a constant amount of memory regardless of the input form.</p><ul><li><p>finite <strong>control device</strong>:in any moment it can be in one of its <strong>states</strong>. it is hard-wired how it changes from one state to another.</p></li><li><p>states:(initial states,favourable states)</p></li><li><p>input tape:divied into cells</p></li><li><p>how it starts:</p><ul><li>the finite control device is in its unique initial state.<br>这句话是什么意思？？</li><li>the reminder</li></ul></li><li><p>how it works:</p><ul><li><p>moves the reading head</p></li><li><p>choose the next state of its control device???<br>这句话什么意思？？</p></li><li><p>the control device is hard-wired------the next state depends on</p><ul><li>the previous state</li><li>the character read from the tape</li></ul></li><li><p>ending:</p><ul><li>if control device is in a favourable state: the input word is accepted</li><li>otherwise: rejected</li></ul></li></ul></li><li><p><strong>state transition diagrams</strong></p><ul><li>directed multigraph<ul><li>点：the states</li><li>箭头线的标签：input</li></ul></li></ul></li></ul><h1 id="九-DFAs-vs-languages"><a href="#九-DFAs-vs-languages" class="headerlink" title="九  DFAs vs. languages"></a>九  DFAs vs. languages</h1><h2 id="PPT提纲-12-3晚"><a href="#PPT提纲-12-3晚" class="headerlink" title="PPT提纲 ----12.3晚"></a>PPT提纲 ----12.3晚</h2><ol><li>how to determine the language of a DFA</li><li>pattern matching</li><li>combine 2 automata</li><li>nondeterminism</li><li>NFA</li><li>P262??</li><li>equivalence of DFAs and NFAs</li><li>subset construction</li></ol><h1 id="作业中易错点总结"><a href="#作业中易错点总结" class="headerlink" title="作业中易错点总结"></a>作业中易错点总结</h1><ol><li>---11.14 五 概率<ol><li>题型: 要运用贝叶斯定理的题目,1. 先画个<em>二叉树</em>帮助理解, 2. 计算时哪个包含哪个一定要搞清楚</li><li>判断indenpent: 三个公式</li></ol></li><li>---11.14 Small六<ul><li>六个工作分给五个人的答案没理解</li></ul></li><li>---11.14 六 graph<ul><li>isomorphic: f是bijection(one-to-one&amp;onto)</li><li>invariant</li><li>题型:判断一句话是否是invariant: 与onto和one-to-one结合为题目服务(例题好好理解)</li><li>题型:根据题干描述画graph时,注意看清楚给出的要求的类型!</li><li>题型:证明两个graph是isomorphic的: 画出图,再一一f对应</li><li>Largetutorial最后一题:只能说思维要开阔了…</li></ul></li></ol><h1 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问"></a>疑问</h1><ol><li>---11.13 六graph里directed graph的计算edge的公式,一个点可以同时有in和out,且数量不同,那怎么算?</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;六-graphs&quot;&gt;&lt;a href=&quot;#六-graphs&quot; class=&quot;headerlink&quot; title=&quot;六 graphs&quot;&gt;&lt;/a&gt;六 graphs&lt;/h1&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="FC" scheme="https://jianai0330.github.io/categories/2019/KCL/FC/"/>
    
    
  </entry>
  
  <entry>
    <title>PPA_notes</title>
    <link href="https://jianai0330.github.io/2019/11/03/ppa/"/>
    <id>https://jianai0330.github.io/2019/11/03/ppa/</id>
    <published>2019-11-03T08:34:48.000Z</published>
    <updated>2019-12-11T20:53:03.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="term-1-上课知识"><a href="#term-1-上课知识" class="headerlink" title="term 1 上课知识"></a>term 1 上课知识</h1><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><a href="https://blog.csdn.net/haovip123/article/details/42890579" target="_blank" rel="noopener" title="变量&amp;数据类型">数据类型</a><ol><li>基本数据类型占用内存及取值范围</li></ol></li><li>成员变量:fields 静态变量:用static修饰 局部变量:local<br><a href="https://blog.csdn.net/haovip123/article/details/43883109" target="_blank" rel="noopener" title="比较+理解">之间的比较</a><ol><li>static 被所有<strong>对象</strong>共享</li></ol></li><li><strong>this</strong>关键字<a href="https://www.cnblogs.com/lblxiaoyu/archive/2007/08/30/875603.html" target="_blank" rel="noopener" title="理解this">详细的理解</a></li><li>String <a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener" title="String">对字符串的深入理解</a></li><li></li></ol><h2 id="一-二-week1-amp-2"><a href="#一-二-week1-amp-2" class="headerlink" title="一 二 week1&amp;2"></a>一 二 week1&amp;2</h2><ol><li>state: 状态</li><li>fields define the state of an object</li><li>+:overloading:运算符/连接符</li></ol><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><ol><li>类图&amp;对象图</li><li>modulo运算符</li></ol><h2 id="四-grouping"><a href="#四-grouping" class="headerlink" title="四 grouping"></a>四 grouping</h2><ol><li><a href="https://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener" title="collection">collection</a></li><li></li></ol><h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><h3 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h3><ol><li>wihle loop</li><li>for-each</li><li><h4 id="searching"><a href="#searching" class="headerlink" title="searching:"></a>searching:</h4>  loop condition: <em>index &lt; files.size() &amp;&amp; !found</em></li><li>不要用input == “bye”比较两个string,一定要用只能用<p>input.equals(“bye”)</p></li><li>Iterator与iterator():<br>   iterator()是collection有的一个method,return一个Iterator类的object,这个object可以用这几个Iterator类里的method:<strong>hasNext,next,remove</strong><br>   格式:<code>Iterator&lt;ElementType&gt; it = myCollection.iterator()</code></li><li>Index vs Iterator:<strong>remove</strong>的时候用iterator,</li><li>anonymous objects</li></ol><h2 id="week7-Chapter6"><a href="#week7-Chapter6" class="headerlink" title="week7 Chapter6"></a>week7 Chapter6</h2><h3 id="研读课本"><a href="#研读课本" class="headerlink" title="研读课本"></a>研读课本</h3><ol><li>responsibility-driven design, cohesion, coupling, refactoring</li><li>intance method:invoked on an <strong>intance</strong> of a class, 注意class method和instance method不互通不能互相引用</li><li>enum(enumerated types):枚举<br>枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部<br><a href="https://blog.csdn.net/qq_27093465/article/details/52180865" target="_blank" rel="noopener" title="深入理解">深入理解枚举</a><h3 id="预习PPT-amp-提纲"><a href="#预习PPT-amp-提纲" class="headerlink" title="预习PPT&amp;提纲"></a>预习PPT&amp;提纲</h3><ol><li>几个class:random</li><li>Set,Map<br>hashSet,hashMap</li><li>list,map和set的比较</li><li>wrapper classes<br>int 和 Interger</li><li>autoboxing and unboxing</li><li>static</li></ol></li></ol><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><h3 id="yi"><a href="#yi" class="headerlink" title="yi"></a>yi</h3><ol><li>为什么add（E e）返回的是boolean</li><li>random的引用</li><li>selecting random responses<ul><li>responses的arraylist是怎么产生的</li></ul></li></ol><h2 id="八-Week-8"><a href="#八-Week-8" class="headerlink" title="八 Week 8"></a>八 Week 8</h2><h3 id="上课-ppt"><a href="#上课-ppt" class="headerlink" title="上课 ppt"></a>上课 ppt</h3><ol><li><p>cohesion:  each unit is responsible for one single logical task<br> unit: class, method<br> 关于hashmap的</p><ul><li>两个元素，前面的是key，后面value</li></ul></li><li><p>2 important: coupling: loose coupling  : interface,change 1 do not need to change another.</p></li><li><p>周五上课---看的回放----11.18<br>1.</p><ul><li><p>arraylist和hashmap等等里面不能有primitive types</p></li><li><p>primitive types(int,boolean等等)不是object</p></li><li><p>引出wrapper class(Interger,Float…)</p></li><li><p>primitive-type values wrap in objects to be stored in a <strong>collection</strong></p></li><li><p>autoboxing &amp; unboxing</p></li><li><p><a href="https://blog.csdn.net/chenliguan/article/details/53888018" target="_blank" rel="noopener" title="int和Integer">int和Integer的比较</a></p></li><li><p><a href="https://blog.csdn.net/Teacher_Lee_ZZSXT/article/details/79230501" target="_blank" rel="noopener" title="更详细的比较">这个讲的更详细</a></p><ol start="2"><li>class variables</li></ol></li><li><p>shared between all instances of the class.</p></li><li><p>属于class, 独立于instances</p></li><li><p>有keyword:<strong>static</strong></p></li><li><p>用class的name在引用.前</p></li><li><p>与fields的区别?:field属于class的对象里??</p></li><li><p>用于:在一个class里不同的对象都需要用的变量</p><ol start="3"><li>constant</li></ol></li><li><p><strong>final</strong></p></li><li><p>用final修饰普通变量通常分为两种情况，修饰普通基本类变量和修饰引用类型变量，也就是对象类型变量</p></li><li><p>不能change</p></li><li><p>可以是public的</p></li><li><p>static final : 经常的组合</p></li><li><p>class constants:变量名大写</p></li><li><p>疑惑:final,constant和fields…static的关系</p></li><li><p>static和final得关系</p></li><li><p>final修饰的变量称为常量，这些变量只能赋值一次，final 的变量不能被修改<br>final修饰的引用类型变量,表示该变量的引用不能变,而不是该变量的值不能变;使用final能保证变量不能改变引用的目标，却不能保证变量所引用的目标本身的变化。因为对于基本类型，我们可以把变量看作是变量值的本身；而对于引用类型变量，变量和变量的值需要区分看待，它们只是以某种方式被关联起来了而已，事实上它们是不同的东西，所以final无法同时作用于两者身上</p></li><li><p><em>static</em>:field/method: 独立于对象属于class</p><ol><li>class method</li></ol></li><li><p>static的方法都是class method</p></li><li><p>可直接调用</p></li><li><p>那存在的必要是什呢,跟其他的object method比<br>---不 depend于object</p></li><li><p>limitations: instance method can call class method, but class method cannot call instance method and instance fields. </p><p>也就是说它只能用static fields,但object method 能用所有fields.</p><ol start="2"><li>outside bluej<br><code>public static void main(String[] arg)</code></li></ol></li></ul></li></ol><h2 id="九-week9"><a href="#九-week9" class="headerlink" title="九 week9"></a>九 week9</h2><h3 id="Using-java-without-bluej"><a href="#Using-java-without-bluej" class="headerlink" title="Using java without bluej"></a>Using java without bluej</h3><ol><li>几个文件的后缀：java，class,txt..</li><li>Javac :终端命令，是java编译器的名称？</li><li>Javac 把.java变成.class(全是2进制)</li><li>Emacs命令</li><li>java命令（后接类名无后缀）start JVM，开始执行程序</li><li>the edit-compile-execute cycle：理解JVM<br>Editor---source file---compiler(javac)---class file---virtual machine(java)</li><li>每个system都有其JVM</li><li>main method应该做什么 ---PPT里</li><li>JDK: Java Development Kit，Java开发工具包,是用来编译、调试Java程序的开发工具包。包括Java工具（javac/java/jdb等）和Java基础的类库（java API ）<br>JVM（Java Virtual Machine， Java虚拟机）是JRE的一部分<h3 id="Fixed-sized-collections"><a href="#Fixed-sized-collections" class="headerlink" title="Fixed-sized collections"></a>Fixed-sized collections</h3></li><li>Arrays的特性<ul><li>Fixed in length 他在讲什么memory之类的东西。。。</li><li>Use a special syntax语法</li><li>它的对象没有methods，methods从其他class而来</li><li>methods都是static的</li></ul></li><li>-最大size可以？？</li><li>与List的不同之处arrays可以store对象引用和基础数据类型</li><li>例子project：weblog-analyzer</li><li>array的语法</li><li>array更改element的原理</li><li>array literals</li><li>array length 是field<h3 id="周五11-22的回看11-25"><a href="#周五11-22的回看11-25" class="headerlink" title="周五11.22的回看11.25"></a>周五11.22的回看11.25</h3></li><li>for-each loop: remove和add会导致error<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.startWith(<span class="string">"t"</span>))&#123;</span><br><span class="line">    list.remove(s);</span><br><span class="line">    <span class="comment">//如果remove,会skip</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>为何呢</li><li>用 for loop? ---也不好</li><li>解决办法:<strong>Iterator</strong>(用while)</li><li>Iterator用for的话,最后一个counter不需要</li><li><a href="https://blog.csdn.net/github_2011/article/details/54927531" target="_blank" rel="noopener" title="总结">遍历list删除元素的总结</a></li></ul><ol start="2"><li>二维数组[][]<ol><li>例子:brain</li></ol><ul><li>Environment里面的setup好奇怪</li></ul><ol start="2"><li>处理图片就是处理二维数组</li></ol></li></ol><h2 id="十-week10"><a href="#十-week10" class="headerlink" title="十 week10"></a>十 week10</h2><p>functional processing of collections</p><h3 id="预习PPT提纲"><a href="#预习PPT提纲" class="headerlink" title="预习PPT提纲"></a>预习PPT提纲</h3><ol><li>Lambdas<ul><li>code can be treated as data</li><li>segments of code can be stored in variables,passed as para</li><li>它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。<br>你可以将其想做一种速记，在你需要使用某个方法的地方写上它</li><li><code>(argument) -&gt; (body)</code></li><li>每个 Lambda 表达式都能隐式地赋值给函数式接口</li></ul></li><li>Method vs Lambdas</li></ol><ol start="2"><li>Stream</li><li>filter，map，reduce</li><li>pipelines</li><li><strong>::</strong>的四种使用</li></ol><h3 id="周五的recording"><a href="#周五的recording" class="headerlink" title="周五的recording"></a>周五的recording</h3><h2 id="十一-Junit-amp-amp-test"><a href="#十一-Junit-amp-amp-test" class="headerlink" title="十一 Junit&amp;&amp;test"></a>十一 Junit&amp;&amp;test</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>Junit: a java test framework</li><li>test cases: methods </li><li>test classes: 用于assert expected method results</li><li>fixtures: support multiple tests(一个起始状态,多个对象)</li><li>test harness: </li><li>test driven development</li></ol><h2 id="疑惑与计划"><a href="#疑惑与计划" class="headerlink" title="疑惑与计划"></a>疑惑与计划</h2><ol><li>auction project的源代码 看 ---11.4早于lse</li></ol><h1 id="语法-amp-逻辑知识"><a href="#语法-amp-逻辑知识" class="headerlink" title="语法&amp;逻辑知识"></a>语法&amp;逻辑知识</h1><ol><li><p>java的operator overloading: string的+</p></li><li><p><a href="https://www.runoob.com/java/java-inheritance.html" target="_blank" rel="noopener" title="extends">类的继承</a></p></li><li><p><a href="https://www.jianshu.com/p/a59a31eb3a41" target="_blank" rel="noopener" title="匿名类">匿名类的简单理解</a></p></li></ol><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h3 id="brain"><a href="#brain" class="headerlink" title="brain"></a>brain</h3><ol><li>cells二维数组的初始化令人迷惑</li></ol><h1 id="网址干货收藏"><a href="#网址干货收藏" class="headerlink" title="网址干货收藏"></a>网址干货收藏</h1><ol><li><a href="https://songlee24.github.io/2016/03/16/java-basic-note-1/" target="_blank" rel="noopener" title="java基础知识">java基础博客</a></li><li><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener" title="清华大学课程">清华大学计算机系课程</a></li><li><a href="https://zhuanlan.zhihu.com/p/31650418?utm_source=wechat_timeline&utm_medium=social&utm_oi=898106614555504640&from=timeline&isappinstalled=0" target="_blank" rel="noopener" title="知乎AI入门">知乎人工智能入门</a></li><li><a href="https://www.zhihu.com/question/23148377/answer/863990767" target="_blank" rel="noopener" title="要掌握的算法">要掌握的算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;term-1-上课知识&quot;&gt;&lt;a href=&quot;#term-1-上课知识&quot; class=&quot;headerlink&quot; title=&quot;term 1 上课知识&quot;&gt;&lt;/a&gt;term 1 上课知识&lt;/h1&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="PPA" scheme="https://jianai0330.github.io/categories/2019/KCL/PPA/"/>
    
    
  </entry>
  
  <entry>
    <title>Arduino与Assembly</title>
    <link href="https://jianai0330.github.io/2019/11/01/arduino/"/>
    <id>https://jianai0330.github.io/2019/11/01/arduino/</id>
    <published>2019-11-01T16:22:08.000Z</published>
    <updated>2019-11-02T18:23:20.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab–汇编语言初识-amp-语法结构"><a href="#Lab–汇编语言初识-amp-语法结构" class="headerlink" title="Lab–汇编语言初识&amp;语法结构"></a>Lab–汇编语言初识&amp;语法结构</h2><a id="more"></a><h3 id="第一个程序的理解"><a href="#第一个程序的理解" class="headerlink" title="第一个程序的理解"></a>第一个程序的理解</h3><ol><li>.equ SREG,0x3f     :treat the label SREG as 0x3f</li><li>.org 0     :the start address</li><li>r16--r31,PPRB,PORTC等等在microprocessor’s CPU也就是Atmega328p里</li></ol><h2 id="lab2-portb-连led"><a href="#lab2-portb-连led" class="headerlink" title="lab2 portb 连led"></a>lab2 portb 连led</h2><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><ol><li><h4 id="SREG-status-register"><a href="#SREG-status-register" class="headerlink" title="SREG : status register"></a>SREG : status register</h4></li><li><h4 id="Rd-Destination-register-in-the-register-file"><a href="#Rd-Destination-register-in-the-register-file" class="headerlink" title="Rd : Destination register in the register file"></a>Rd : Destination register in the register file</h4></li></ol><h3 id="arduino里几个概念"><a href="#arduino里几个概念" class="headerlink" title="arduino里几个概念"></a>arduino里几个概念</h3><ol><li><h4 id="ATmega是Arduino里面的正方形芯片-microcontroller"><a href="#ATmega是Arduino里面的正方形芯片-microcontroller" class="headerlink" title="ATmega是Arduino里面的正方形芯片,microcontroller"></a>ATmega是Arduino里面的正方形芯片,microcontroller</h4></li><li><h4 id="PORTB"><a href="#PORTB" class="headerlink" title="PORTB"></a>PORTB</h4><pre><code>: an 8-bit I/O port with internal pull-up resistors, 位于: 正方形芯片的周边小点(8个:PB7:0)它们 连接着the external digital pins</code></pre><table><thead><tr><th>Atemega pin</th><th>Nano digital pin</th></tr></thead><tbody><tr><td>PB0(在芯片的四周))</td><td>D8(在nano的两周,可连接面包板的线)</td></tr><tr><td>PB1</td><td>D9</td></tr><tr><td>….</td><td>….</td></tr></tbody></table></li><li><h4 id="digital-pin"><a href="#digital-pin" class="headerlink" title="digital pin:"></a>digital pin:</h4><pre><code>位于nona两周: I/O interface(HIGH/LOW)</code></pre></li><li>CPU怎么链接PORTB: databus</li><li>DDRB跟PORTB,PORTC等等地位相等,都在register里,都是一个一个的寄存器,都是8bit.(each port on Atmega328 has a <strong>Data Direction Register</strong>)</li><li>DDRB和PORTB的<strong>关系</strong>:<br>  each bit of in PORTB has a corresponding input or output mode bit in DDRB.<h2 id="Lab3-portc-很好理解-读value"><a href="#Lab3-portc-很好理解-读value" class="headerlink" title="Lab3 portc 很好理解 读value"></a>Lab3 portc 很好理解 读value</h2></li></ol><h2 id="疑问疑惑"><a href="#疑问疑惑" class="headerlink" title="疑问疑惑"></a>疑问疑惑</h2><h3 id="程序内的语法"><a href="#程序内的语法" class="headerlink" title="程序内的语法:"></a>程序内的语法:</h3><ol><li>main,mainloop的意思</li><li>rjmp?</li><li>brlo <strong>lessthan</strong>? 为什么是lessthan,brlo本身不就是当lower时吗</li><li>.org 0,地址0 是跟0x06等等同一地位吗,那我在.equ里面最小的那个地址开始可以吗 --11.3<h3 id="led-on-s"><a href="#led-on-s" class="headerlink" title="led_on.s:"></a>led_on.s:</h3></li><li>SREG的作用是什么,设置为0要干什么<h3 id="第三个程序-portc-lab3"><a href="#第三个程序-portc-lab3" class="headerlink" title="第三个程序:portc(lab3)"></a>第三个程序:portc(lab3)</h3></li><li>从PINC中读取数据到PORTC,那pinc的数据从何而来?</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lab–汇编语言初识-amp-语法结构&quot;&gt;&lt;a href=&quot;#Lab–汇编语言初识-amp-语法结构&quot; class=&quot;headerlink&quot; title=&quot;Lab–汇编语言初识&amp;amp;语法结构&quot;&gt;&lt;/a&gt;Lab–汇编语言初识&amp;amp;语法结构&lt;/h2&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="Arduino" scheme="https://jianai0330.github.io/categories/2019/KCL/Arduino/"/>
    
    
      <category term="单片机" scheme="https://jianai0330.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>CS_note</title>
    <link href="https://jianai0330.github.io/2019/10/31/assembly/"/>
    <id>https://jianai0330.github.io/2019/10/31/assembly/</id>
    <published>2019-10-31T13:24:07.000Z</published>
    <updated>2019-11-03T12:35:41.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五-performance-measurement-and-analysis"><a href="#五-performance-measurement-and-analysis" class="headerlink" title="五 performance measurement and analysis"></a>五 performance measurement and analysis</h1><a id="more"></a><h2 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li><p>性能equation : 1. CPU time 2. Amdahl’s law</p></li><li><p>benchmarking: </p></li><li><p>性能optimisation:<br>RISA&amp;CISC(the two main kinds of ISA design)<br>  <strong>RISC</strong>:reduced instruction set computers   <strong>shorten time by reducing clock cycle</strong></p><pre><code>simple instructions,few addressing mode</code></pre><p>  <strong>CISC</strong>:complex isc <strong>reduce the number of instructions per program</strong></p><pre><code>complex instructions,many addressing modes</code></pre><p>Branch optimisation: pipeline hazards<br>delayed branching<br>Branch prediction</p></li><li><p>disk性能: 概念: utilisation U<sub>d</sub>=r<sub>req</sub> / r<sub>srv</sub><br>FCFS: first-come,first served<br>SSTF:shortest seek time first(出现starvation的概念)<br>SCAN:not an acronym<br>C-SCAN:circular SCAN<br>LOOK/C-LOOK</p><p>注意比较各种情况下的好坏</p><h2 id="课上和课后总结理解难点"><a href="#课上和课后总结理解难点" class="headerlink" title="课上和课后总结理解难点"></a>课上和课后总结理解难点</h2><ol><li>flushing the pipeline: conditional branck instructions</li><li>clock rate=machine cycles per second</li><li></li><li></li></ol></li></ol><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol><li>CPU里clock cycle的理解</li><li>对于RAM里的两种memory ports: 1. 32-bits for data/address 2. 8-bit for OPCODE,<br> 是说每个横格长都是40bit吗,每一个data前面都有8bit的OPCODE吗,那怎么行得通呢</li><li>byte-addressable &amp; word-addressable:<pre><code>byte..:every byte has its own address. (word:every word) </code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;五-performance-measurement-and-analysis&quot;&gt;&lt;a href=&quot;#五-performance-measurement-and-analysis&quot; class=&quot;headerlink&quot; title=&quot;五 performance measurement and analysis&quot;&gt;&lt;/a&gt;五 performance measurement and analysis&lt;/h1&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="CS" scheme="https://jianai0330.github.io/categories/2019/KCL/CS/"/>
    
    
      <category term="CS" scheme="https://jianai0330.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>CS</title>
    <link href="https://jianai0330.github.io/2019/10/31/cs/"/>
    <id>https://jianai0330.github.io/2019/10/31/cs/</id>
    <published>2019-10-31T13:24:07.000Z</published>
    <updated>2019-12-03T22:23:19.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h2><a id="more"></a><h1 id="二-Assembly-1"><a href="#二-Assembly-1" class="headerlink" title="二 Assembly 1"></a>二 Assembly 1</h1><ol><li><p>CPU<br> registers<br> ALU<br> control unit<br> data bus</p></li><li><p>memory organisation<br> byte-addressable/word-addressable<br> RAM chips:random access memory  lengthXwidth</p></li><li><p>I/O</p></li><li><p>Bus</p></li><li><p>Clocks<br> clock cycles<br> clock frequency(互为倒数)<br> CPU time</p></li><li><p>Interrupts</p></li><li><p>MARIE ISA</p><ul><li>load: load contents of address x into AC</li><li>store: store the contents of AC at address X</li><li>add</li><li>subt</li><li>input/output</li><li>halt: 暂停</li><li>skipcond: skip next instruction on condition</li><li>jump X: load the value of X into PC<br>那么load store jump好像没区别啊?</li></ul></li><li><p>RTL: register transfer language</p><h1 id="三-Assembly-2"><a href="#三-Assembly-2" class="headerlink" title="三 Assembly 2"></a>三 Assembly 2</h1></li><li><p>fetch-decode-execute cycle<br> PC<br> MAR<br> IR<br> PC<br> MAR<br> MBR</p></li><li><p>Interrupt processing:PPT上有两个流程图<br>  flags register<br>  maskable<br>  Nonmaskable interrupts</p></li><li><p>注意PPT里一个简单program在computer里运行的流程图!</p></li><li><p>Assemblers汇编器的工作流程:PPT!<br>  1st pass: symbol table<br>  2nd pass: the instructions are completed using the value from the <strong>symbol table</strong>.<br>  完成将汇编语言变成机器语言的过程</p></li><li><p>一个汇编语言程序:main和mainloop是address label.?? main&amp;mainloop的理解</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.equ</span> <span class="built_in">SREG</span>,<span class="number">0x3F</span></span><br><span class="line"><span class="meta">.org</span></span><br><span class="line"><span class="symbol">main:</span>   <span class="keyword">ldi</span> <span class="built_in">r16</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">out</span> <span class="built_in">SREG</span>,<span class="built_in">r16</span></span><br><span class="line"><span class="symbol">mainloop:</span> <span class="keyword">rjmp</span> mainloop</span><br></pre></td></tr></table></figure></li><li><p>indirect addressing mode时:</p></li><li><p>JnS:operates by storing the current PC value in the first address of the routine itself,then continue with the instruction following that.    Jump-and-store.<br> JumpI:return from the subroutine.</p></li><li><p>Clear</p></li><li><p>if</p></li><li><p>for/while</p></li><li><p>Procedure invocation:f()</p></li><li><p>两个samole constructs!!</p><h1 id="四-instruction-set-architectures-pipelines"><a href="#四-instruction-set-architectures-pipelines" class="headerlink" title="四 instruction set architectures/pipelines"></a>四 instruction set architectures/pipelines</h1></li><li><p>instruction formats</p><ol><li>little endian<br>big endian:正常的<br>比较: ///</li><li>how the CPU store data(3种)CPU的特殊内部存储结构<br><img src="https://wkretype.bdimg.com/retype/zoom/6a64416127d3240c8447ef13?pn=7&o=jpg_6&md5sum=1830449c7405e4dd2a4f0bb2c1b9644e&sign=df6cd0909c&png=126611-139487&jpg=805027-909057" alt="三种结构"><ol><li>stack: instructions and operands都从stack里拿,先进后出<br> stack机器用1/0operand instructions<br> Push X, Pop X<br> Add/Mult</li><li>accumulator: operand在memory中</li><li>general purpose register: 比accumulator快,instructions更长:<br> Memory-memory:<br> register-memory:至少1个operand在register.<br> load-store:无operand在memory.   </li></ol></li><li>注意0123address machimes 的code(作业中有) </li></ol></li><li><p>instruction types</p></li><li><p>addressing: where the <strong>operand</strong> is located.(a constant, a register, memory location)<br>  immediate<br>  direct<br>  indirect<br>  indexed:final=base+index</p></li><li><p>instruction level Pipelining<br> S = NKt<sub>p</sub> / (K+N-1)t<sub>p</sub><br> =K<br> pipeline hazards隐患</p></li></ol><h1 id="五-performance-measurement-and-analysis"><a href="#五-performance-measurement-and-analysis" class="headerlink" title="五 performance measurement and analysis"></a>五 performance measurement and analysis</h1><h2 id="PPT提纲"><a href="#PPT提纲" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li><p>性能equation : 1. CPU time 2. Amdahl’s law</p></li><li><p>benchmarking: </p></li><li><p>性能optimisation:<br>RISA&amp;CISC(the two main kinds of ISA design)指令集类型<br>  <strong>RISC</strong>:reduced instruction set computers   <strong>shorten time by reducing clock cycle</strong></p><pre><code>simple instructions,few addressing mode</code></pre><p>  <strong>CISC</strong>:complex isc <strong>reduce the number of instructions per program</strong></p><pre><code>complex instructions,many addressing modes</code></pre><p>Branch optimisation: pipeline hazards<br>delayed branching<br>Branch prediction</p></li><li><p>disk性能: 概念: utilisation U<sub>d</sub>=r<sub>req</sub> / r<sub>srv</sub><br>FCFS: first-come,first served<br>SSTF:shortest seek time first(出现starvation的概念)<br>SCAN:not an acronym<br>C-SCAN:circular SCAN<br>LOOK/C-LOOK</p><p>注意比较各种情况下的好坏</p><h2 id="课上和课后总结理解难点"><a href="#课上和课后总结理解难点" class="headerlink" title="课上和课后总结理解难点"></a>课上和课后总结理解难点</h2></li></ol><h1 id="七-二进制①-JoshM"><a href="#七-二进制①-JoshM" class="headerlink" title="七 二进制① JoshM"></a>七 二进制① JoshM</h1><h2 id="PPT提纲-1"><a href="#PPT提纲-1" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li><p>negative numbers in binary: 几个概念: unsighed binary<br> formats: </p><ol><li><p>signed magnitude  : MSB(the most significant bit) is a sign bit---0+&amp;1-  源码<br>0的源码有两种:00000000&amp;10000000,0的补码只有:00000000.</p></li><li><p>One’s complement. 反码</p></li><li><p>Two’s complement  补码(对于正数补码相同)<br>  [X]<sub>补</sub> = X + M<br>  这个M是mod M,模数M根据机器数的位数而定,位数为81则M=2<sup>8</sup><br>对于负数:<br>1.真值:将各位变反,then最低位+1<br>2.源码: 符号位不变,其余各位变反then最低位+1<br>11111111是-1的补码,10000000是-128的补码.0的补码只有一个:00000000.</p></li><li><p>注意优缺点!!!(PPT17)</p></li><li><p>各方式表示的范围(8bits)<br>unsigned binary: 0 ---255<br>源码:-127(11111111)---+127(01111111)<br>反码:-127(11111111)---+127(01111111)<br>补码:-128(10000000)---+127(01111111)</p></li></ol></li></ol><h2 id="二进制运算法则"><a href="#二进制运算法则" class="headerlink" title="二进制运算法则"></a>二进制运算法则</h2><pre><code>1. 10转2:减权定位         除基取余(直到商为0):从最**下面**的余数开始!   小数10转2:减权定位            乘基取整:从最上面的整数数开始2. 2转10: 按权相加(小数2转10同)3. 十转八:除基取余比较简单</code></pre><h1 id="八-binary-②"><a href="#八-binary-②" class="headerlink" title="八 binary ②"></a>八 binary ②</h1><h2 id="上课-PPT"><a href="#上课-PPT" class="headerlink" title="上课 PPT"></a>上课 PPT</h2><ol><li><p>unsigned: </p><ol><li>unsigned addtion---<strong>overflow</strong><ul><li>是一个圈,从111再加就是000了</li><li>incrementinf by one <strong>?!?!</strong> 那几句话没理解PPT第5页</li></ul></li><li>subtraction (注意借位,需要练习)<ul><li>first check the minus…???</li></ul></li><li>multipication<ul><li>感觉像分列式,分几个part乘,最后加一起.</li></ul></li><li>division: 很像十进制的除法方式.</li></ol></li><li><p>signed magnitude arithmetric:</p><ol><li>加<ol><li>check the <strong>sign</strong> firstly</li><li>如果<strong>符号不同</strong>: 比较绝对值大小------用大的减小的------用绝对值大的数的sign.</li><li>overflow 那个圈没理解</li></ol></li><li>减<ol><li>x-y: - y如果是<code>负</code>------变成<strong>x+(-y)</strong><ul><li>y是<code>正</code>且x是<code>负</code>----变成<em>-(-x+y)*</em></li><li>y是<code>正</code>且x是<code>正</code>----变成<strong>(-y)+x</strong></li><li>但我第一次做作业,全错…</li></ul></li></ol></li></ol></li><li><p>one’s complement arithmetic</p><ol><li>反码,加完多一位,再加(多么神奇…需要记忆以及与其它区分)</li></ol></li><li><p>two’s complement arithmetic</p><ol><li>忽略加完后的第一位.</li><li><strong>detecting overflow</strong><br> 新概念:carry和borrow<br> carry-in = carry-out------no overflow<br> but这个是怎么计算的???</li></ol></li><li><p>Error detection and correction:</p><ol><li>hamming distance:不同的位数</li><li>parity bit :要sufficient才能correct error,</li><li>code word : 存在的必要是什么</li><li>是在bus上传递数据用的吗?那学过的存储模式pocode+address跟这个是什么关系?</li></ol></li></ol><h2 id="重难点解析"><a href="#重难点解析" class="headerlink" title="重难点解析"></a>重难点解析</h2><ol><li>三个overflow的图一定要好好理解.</li><li><del>真值,补码,反码,源码之间的变化!!</del></li><li>补码overflow detect</li><li>sign的减法和乘除</li></ol><h1 id="九-floating-point-binary"><a href="#九-floating-point-binary" class="headerlink" title="九 floating-point binary"></a>九 floating-point binary</h1><h2 id="预习-回看"><a href="#预习-回看" class="headerlink" title="预习+回看"></a>预习+回看</h2><ol><li><p>Scientific notation</p><ul><li>two parts: <strong>significand</strong> &amp; <strong>exponent</strong></li><li>exponent指数: 能表示negative, 所以有了<em>bias</em></li><li>bias: single precision:<strong>127</strong> double precision:<u>1023</u></li></ul></li><li><p>IEEE: institute of Electrical and Electronics Engineers</p><ul><li>standard: single precision and double precision</li><li>bias</li><li>bias与two’s complement的比较<br>why use a bias instead of two’s complement补码<br>a bias allows the numetric ordering to be the same as the lexicographic ordering<br>没理解上面这句话</li></ul></li><li><p>significand:</p><ul><li>normalised 有一个implied的<code>1.</code></li><li>why is the significand normalised?<br>an extra bit of preciison because of <code>1.</code><br>ensure a unique representation</li></ul></li><li><p>converting from decimal</p></li><li><p>special value</p></li><li><p>IEEE-754 format arithmetic</p><ul><li>addition</li><li>multiplication</li></ul></li><li><p>Range , precision , accuracy</p></li><li><p>accuracy: related error</p></li></ol><h2 id="题型总结"><a href="#题型总结" class="headerlink" title="题型总结"></a>题型总结</h2><ol><li>十进制和IEEE754的相互转化</li></ol><h1 id="十-the-memory-hierarchy"><a href="#十-the-memory-hierarchy" class="headerlink" title="十 the memory hierarchy"></a>十 the memory hierarchy</h1><p><code>hierarchy</code>阶层</p><h2 id="PPT提纲-2"><a href="#PPT提纲-2" class="headerlink" title="PPT提纲"></a>PPT提纲</h2><ol><li><p>memory addresses</p><ol><li>a word: smallest addressable unit</li><li>blocks :</li><li>two fields of a memory address:<ul><li>block field</li><li>offset field</li></ul></li></ol><ul><li>记住一个二级结论: 2^n的二进制值用n位2进制数表示</li></ul></li></ol><ol start="2"><li><p>Overview of the memory hierarchy</p></li><li><p>Caches : a type of memory that is smaller and faster than main memory</p><ul><li>usage patterns 3个<br>还有几个公式:<br>Hit ratio……<br>Miss ratio……<br>Hit ratio + Miss ratio = 1<br>!!!EAT(effective access time)!!!<br>reduce EAT as much as possible<br>can also be overlapped: parallel : EAT公式不同!</li><li>expected access times</li></ul></li><li><p>Cache systems<br> search tags : different approaches : 三种</p><ul><li><p>direct-mapped</p><ol><li><code>Y = X mod N</code><br>Y:cache block<br>X:block of main memory<br>N:cahce总的blocks<br>mod取余</li><li>tag field : 注意P20的例子</li><li>tag+block field+offset field</li></ol></li><li><p>full-associative</p><ol><li>tag+offset field</li><li>directed-mapped vs fully-associative</li></ol></li><li><p>set-associative</p><ol><li>n-way set-associative cache uses n direct-mapped caches in parallel<br>each direct-mapped cache is a set</li><li>疑惑:PPT红线: directed在哪里??? </li></ol></li></ul></li><li><p>replacement policies</p><ol><li>LRU</li><li>FIFO</li><li>Random<br><code>注意优缺点!</code></li></ol></li></ol><h1 id="十一-the-memory-hierarchy2"><a href="#十一-the-memory-hierarchy2" class="headerlink" title="十一 the memory hierarchy2"></a>十一 the memory hierarchy2</h1><h2 id="预习PPT-12-3晚"><a href="#预习PPT-12-3晚" class="headerlink" title="预习PPT----12.3晚"></a>预习PPT----12.3晚</h2><ol><li>Virtual Memory</li><li>Segmentation<ul><li>external fragmentation</li></ul></li><li>Paging<ul><li>internal fragmentation</li><li>translation lookaside buffer </li></ul></li></ol><h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><ol><li>Assembly 2 里 JnS </li><li>那么load store jump好像没区别啊? ---11.6</li><li>对于Assembly1作业中的第3题.醍醐灌顶:<br> A 1-bit address can address two words (0, 1).<br> A 2-bit address can address four words (00, 01, 10, 11).<br> A 3-bit address can address eight words (000, 001, 010, 011, 100, 101, 110, 111).<br> but<img src="https://www.coursehero.com/doc-asset/bg/d6bc39dcf48520faf6897593e05282dad7676ae0/splits/v9.frq.clean/split-1-page-1-html-bg.jpg" alt="答案不一样"></li><li><strong>八---二进制2</strong>需要加强理解和动手去做的:1. <del>三种表示二进制数的转化自己去操作</del>. 2. 进制直接每种情况的转化去运算.   ---11.13</li><li><del>对于加了sign的源码,为什么不是额外加一位呢,不影响原本的真值吗?</del>  ---11.13八课上</li><li>对于补码的运算,手机里的照片 理解和解惑. ---11.13八课上</li><li>---11.13晚自习 二进制转八进制,万一位数除不尽3怎么办?</li></ol><h1 id="作业tutorial-的总结"><a href="#作业tutorial-的总结" class="headerlink" title="作业tutorial 的总结"></a>作业tutorial 的总结</h1><ol><li>---11.13晚,week7,binary1.<ul><li>减权定位终于知道了怎么做</li><li>小数10转2,乘积取整还不会</li><li>4个表示方法的范围需要记住</li></ul></li><li>---11.13晚,week8,binary2.<ul><li>unsigned减法必须是正数,因为它无负数</li><li>unsigned除法中除不尽就用reminder余数</li><li>signed的减法中,1110111-0010001为何overflow呢</li><li>0010101-0110011算不对啊,按照(-y)+x的规则啊</li><li>signed的乘除法,全错.(我原本的方法是忽略头一位,再在最后加上头一位)</li><li>反码的加:01101+00100 为何overflow</li><li>补码的加: carry-in和carry-out和overflow detected 是什么</li><li>一定要记住正数的反码和补码都是它,运算的时候一定要仔细1+1变为0</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h1&gt;&lt;h2 id=&quot;冯诺依曼结构&quot;&gt;&lt;a href=&quot;#冯诺依曼结构&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼结构&quot;&gt;&lt;/a&gt;冯诺依曼结构&lt;/h2&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="CS" scheme="https://jianai0330.github.io/categories/2019/KCL/CS/"/>
    
    
      <category term="CS" scheme="https://jianai0330.github.io/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>MatLab</title>
    <link href="https://jianai0330.github.io/2019/10/30/matlab/"/>
    <id>https://jianai0330.github.io/2019/10/30/matlab/</id>
    <published>2019-10-30T19:50:22.000Z</published>
    <updated>2019-11-18T23:03:25.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><a id="more"></a><h2 id="创建x轴的数组"><a href="#创建x轴的数组" class="headerlink" title="创建x轴的数组"></a>创建x轴的数组</h2><p>s = linspace()<br>与直接[ : : ]</p><h2 id="绘制函数图象时"><a href="#绘制函数图象时" class="headerlink" title="绘制函数图象时"></a>绘制函数图象时</h2><p>syms变量–fplot<br>与直接设置x和y对应数组–plot</p><h2 id="设置坐标轴范围时"><a href="#设置坐标轴范围时" class="headerlink" title="设置坐标轴范围时"></a>设置坐标轴范围时</h2><p>xlim(xmin ymin)和ylim()<br>与aixs[xmin xmax ymin ymax]<br>是一个道理</p><h2 id="绘制图像的几个函数"><a href="#绘制图像的几个函数" class="headerlink" title="绘制图像的几个函数"></a>绘制图像的几个函数</h2><ul><li>plot()</li><li>line():画直线型</li><li>polar():极坐标下绘曲线<h2 id="求函数一段范围内的极值"><a href="#求函数一段范围内的极值" class="headerlink" title="求函数一段范围内的极值"></a>求函数一段范围内的极值</h2></li><li>lab7</li><li>感觉有几种方法</li><li>画分段函数的几种方法:正常拆分开;@x</li></ul><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="创建矩阵的方法"><a href="#创建矩阵的方法" class="headerlink" title="创建矩阵的方法"></a>创建矩阵的方法</h2><ol><li>B=a:h:b;  其中a,b代表一维矩阵（向量）的区间，h为步宽</li><li>zeros(行数,列数).ones,rand同.</li><li></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;疑问&quot;&gt;&lt;a href=&quot;#疑问&quot; class=&quot;headerlink&quot; title=&quot;疑问&quot;&gt;&lt;/a&gt;疑问&lt;/h1&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="MatLab" scheme="https://jianai0330.github.io/categories/2019/KCL/MatLab/"/>
    
    
      <category term="MatLab" scheme="https://jianai0330.github.io/tags/MatLab/"/>
    
  </entry>
  
  <entry>
    <title>CMTE_note</title>
    <link href="https://jianai0330.github.io/2019/10/30/cmte-s-note/"/>
    <id>https://jianai0330.github.io/2019/10/30/cmte-s-note/</id>
    <published>2019-10-30T19:20:08.000Z</published>
    <updated>2019-12-11T01:38:50.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四-Vector-Algebra"><a href="#四-Vector-Algebra" class="headerlink" title="四 Vector  Algebra"></a>四 Vector  Algebra</h1><h2 id="空间直线-空间平面"><a href="#空间直线-空间平面" class="headerlink" title="空间直线,空间平面"></a>空间直线,空间平面</h2><a id="more"></a><h3 id="空间直线几个形式的方程-空间平面的方程"><a href="#空间直线几个形式的方程-空间平面的方程" class="headerlink" title="空间直线几个形式的方程,空间平面的方程."></a>空间直线几个形式的方程,空间平面的方程.</h3><p>Ax +By +Cz + D = 0</p><p>其中n = (A, B, C)是平面的法向量，D是将平面平移到坐标原点所需距离（所以D=0时，平面过原点）</p><h3 id="空间两直线的距离-点到平面以及到直线的距离-公式"><a href="#空间两直线的距离-点到平面以及到直线的距离-公式" class="headerlink" title="空间两直线的距离,点到平面以及到直线的距离 公式"></a>空间两直线的距离,点到平面以及到直线的距离 公式</h3><p>(联立方程)<br><img src="https://pic002.cnblogs.com/img/zdd/201007/2010071013450338.jpg" alt="点到平面" title="公式"></p><h2 id="已知两平面方程求交点坐标"><a href="#已知两平面方程求交点坐标" class="headerlink" title="已知两平面方程求交点坐标"></a>已知两平面方程求交点坐标</h2><h2 id="物理学中的力矩和功"><a href="#物理学中的力矩和功" class="headerlink" title="物理学中的力矩和功"></a>物理学中的力矩和功</h2><p>机械功:work<br>力矩:moment of force<br>     the tendency of a force to make an object <strong>rotate</strong> .<br>两个物理意义不同,符号相同.牛顿-米.<br>力矩<em>t=rXF</em>, 这个r不是功里面那样的在F方向的位移,而是从转轴到施力点的位移矢量.</p><h1 id="五-Matrix-Algebra"><a href="#五-Matrix-Algebra" class="headerlink" title="五 Matrix Algebra"></a>五 Matrix Algebra</h1><h2 id="3阶矩阵运算易错的是"><a href="#3阶矩阵运算易错的是" class="headerlink" title="3阶矩阵运算易错的是:"></a>3阶矩阵运算易错的是:</h2><p>第二列的余子式中两列的顺序: 是从左到右 不是从右到左!</p><h2 id="课件提纲-amp-概念"><a href="#课件提纲-amp-概念" class="headerlink" title="课件提纲&amp;概念"></a>课件提纲&amp;概念</h2><ol><li><p>矩阵---多元方程组</p></li><li><p>changes of  axes 旋转----结合预科课件: 逆时针顺时针</p></li><li><h3 id="几个矩阵和概念"><a href="#几个矩阵和概念" class="headerlink" title="几个矩阵和概念"></a>几个矩阵和概念</h3><ul><li><p>square m,column/row vector,diagonal m,unit/identity ma,symmetric m,upper-/lower-triangular m,diagonal对角矩阵,scalar数量矩阵(主对角元全相等)</p></li><li><p>singular:奇异(行列式为0)</p></li><li><p>trace: 迹sum of <strong>leading diagonal</strong>主对角线(左上右下)</p></li><li><p>A<sup>T</sup>: 手心手背 转置矩阵</p><pre><code>行列式和转置行列式**相等**</code></pre></li><li><p>minor:余子式,cofactor 代数余子式多一个-1的次方</p></li><li><p>adjoint:伴随矩阵 <strong><em>注意特性和公式</em></strong> 代数余子式组成</p></li><li><h4 id="inverse-matrix-逆矩阵"><a href="#inverse-matrix-逆矩阵" class="headerlink" title="inverse matrix: 逆矩阵"></a>inverse matrix: 逆矩阵</h4></li><li><h4 id="Cramer’s-rule卡姆拉法则"><a href="#Cramer’s-rule卡姆拉法则" class="headerlink" title="Cramer’s rule卡姆拉法则 :"></a>Cramer’s rule卡姆拉法则 :</h4></li><li><h4 id="Gaussian-elimination-见矩阵运算板块高斯消元法"><a href="#Gaussian-elimination-见矩阵运算板块高斯消元法" class="headerlink" title="Gaussian elimination: 见矩阵运算板块高斯消元法"></a>Gaussian elimination: 见矩阵运算板块<em>高斯消元法</em></h4></li><li><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref<br></h4><pre><code>row echelon form阶梯型矩阵: 下阶梯,leadingentry是1.rref行简化阶梯形矩阵:在ref基上&lt;p&gt;非零首元所在的列/p&lt;&gt;除了非零首元外，其余元素全为0.每个首项是1.每个矩阵,ref不唯一,**rref唯一**.</code></pre></li><li><p>independent &amp; dependent vectors线性相关无关</p><pre><code>linear combination of vectors线性组合(是一个向量而不是关系)注意根据定义,线性相关是n个向量组成的组,至少其余n-个可以表示一个</code></pre></li><li><p>Rank 秩 :最大线性无关的向量的个数  在ref形势下含非0的行数</p></li><li><p><strong>eigenvalue</strong>特征值</p><pre><code>- characteristic polynomial(PPT72页),特征多项式characteristic equation of A特征方程- eigenvector特征向量-</code></pre></li></ul></li><li><p>注意<strong>矩阵×标量</strong>与行列式×标量的区别: 矩阵式乘每个元素,行列式乘一行.</p></li><li><h3 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结:"></a>公式总结:</h3><ul><li>(AB)<sup>T</sup> = B<sup>T</sup>A<sup>T</sup> &amp; adj(AB) = adj(B)adj(A)</li><li>eigenvalue的性质(PPT末尾)</li><li><code>AA*=A*A=|A|E</code>  (*伴随矩阵)</li><li>A<sup>-1</sup>=(1/|A|)<em>A</em>(可轻易有上一行结合AA<sup>-1</sup>=E推出)</li><li>|A*|=|A|<sup>n-1</sup>  (可轻易有上上一行推出)</li></ul></li><li><h3 id="矩阵运算-化简得基本步骤"><a href="#矩阵运算-化简得基本步骤" class="headerlink" title="矩阵运算,化简得基本步骤"></a>矩阵运算,化简得基本步骤</h3><ul><li>Gaussian elimination<em>高斯消元法</em>:<ol><li>最左上角变为1,依次用第一行的减-把剩下行的第一个数变0,这是第一遍,</li><li>第二遍从第二行开始,把第二行第二列变1,依次用第二行减-使下面的行的第二个数变0,</li><li>直到成为上三角.<pre><code>补充:线性方程组的**初等变换**:      1. 交换两个方程的位置(就好比与换矩阵的行!理解了)      2. 一个方程两端同乘不为0的数      3. 同乘不为0的数后加到另一方程去</code></pre></li></ol></li><li>转化成ref(下阶梯):PPT第58页<pre><code>1. pivot:第一个第一列不为0的行,提到第一行2. 依次把下面行的第一列第一行变为03. 去掉第一列,从新开始找pivot4. 在此基础上转化成**rref**: 找到非0首元,把其上的全变为0</code></pre></li><li>find matrix <strong>rank</strong>:<pre><code>1. 矩阵的ref形式里含有非0行的数量 = 矩阵中independent vector(每一行就是一个vector)</code></pre></li><li>eigenvalue: AX = aX<pre><code>- 已知A可求a- 已知A和a可求X(eigenvector)</code></pre></li><li>矩阵加减:要同规模(与行列式不同,矩阵是每排,行列式不同的那一排(其余的每一排要对应相等))</li><li>矩阵乘法:好比说AB,要求是A的列数等于B的行数, 那么得到的矩阵规模是A的行数B的列数<h2 id="二级结论"><a href="#二级结论" class="headerlink" title="二级结论"></a>二级结论</h2></li><li><h3 id="上三角行列式"><a href="#上三角行列式" class="headerlink" title="上三角行列式"></a>上三角行列式</h3><pre><code>的值D = 对角线元素乘积</code></pre></li><li><h3 id="n阶行列式的性质"><a href="#n阶行列式的性质" class="headerlink" title="n阶行列式的性质"></a>n阶行列式的性质</h3><pre><code>1. 行列式等于它的转置行列式2. 互换行列式中的两行/列,行列式变号(**行列式是一个值数,与矩阵不同**),那矩阵换行呢**??**3. 行列式有两行/列对应相等或者对应成比例,行列式 = 0或者行列式有一行全为0,行列式也为04. 行列式乘一个数,就乘一行,跟矩阵一样??5. 最重要的来了: 把某一行/列元素的k倍加到另一行/列,行列式的值不变不变不变!6. 可以用上述这些进行行列式的计算</code></pre></li><li><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><pre><code>1. 一个特殊行列式: 范德蒙Vandermonde</code></pre></li><li>可交换矩阵commutable: 数量矩阵与同阶任何矩阵,A与单位阵,对角阵与对角阵</li><li>方阵的幂</li><li>矩阵的初等变换: 极其类似行列式的初等变换</li></ul></li></ol><h2 id="疑问疑惑不理解"><a href="#疑问疑惑不理解" class="headerlink" title="疑问疑惑不理解"></a>疑问疑惑不理解</h2><ol><li>矩阵这么乘啊加啊,它行列式的值不会变吗,为什么可以这样</li><li>转化成ref</li><li>怎么用矩阵解三元一次方程(就像解eigenvector)</li><li>我记得我总结过行列式与矩阵的不同??</li><li>记得PPT最后的几个性质 PPT的例题----可以lab时候做---<em>于10.31</em></li></ol><h2 id="难点和做题总结"><a href="#难点和做题总结" class="headerlink" title="难点和做题总结"></a>难点和做题总结</h2><ol><li>求特征向量的时候,就设xyz根据向量积的基本法则求,它们积是0.</li><li></li></ol><h1 id="七-函数的极限"><a href="#七-函数的极限" class="headerlink" title="七 函数的极限"></a>七 函数的极限</h1><h2 id="PPT中的基本英文的概念"><a href="#PPT中的基本英文的概念" class="headerlink" title="PPT中的基本英文的概念:"></a>PPT中的基本英文的概念:</h2><ol><li>夹逼定理:sandwich theorem</li><li>precose(formal) definition of Limit</li><li>one-side limut</li><li>continuity at a point</li></ol><h1 id="八-导数-11-14上课"><a href="#八-导数-11-14上课" class="headerlink" title="八 导数 ---11.14上课"></a>八 导数 ---11.14上课</h1><h2 id="ppt与课本"><a href="#ppt与课本" class="headerlink" title="ppt与课本"></a>ppt与课本</h2><ol><li>课本书签中左右导数的具体计算过程</li><li>注意题型大部分有可能是物理应用</li><li>复习去年学的导数那一章，注意肯定有很多题型（比如说微分什么的计算我记得）</li><li>----11.18上matlab: 搞清楚几种极值,什么<strong>local maximum,absolute minimum</strong>对应的中文概念和此时函数的导数二次导数等等的特性.总结出来!</li><li>在本周quiz中,出现了一个我竟然忘记的东西!! 那就是 函数此点可导的条件有两个,<strong>1此点连续,2左导数=右导数!!!!</strong></li></ol><h1 id="九-微分方程"><a href="#九-微分方程" class="headerlink" title="九 微分方程"></a>九 微分方程</h1><h2 id="ppt提纲"><a href="#ppt提纲" class="headerlink" title="ppt提纲"></a>ppt提纲</h2><ol><li>first-order initial value problem</li><li>slope fields</li><li><strong>[Euler’s method]</strong>(<a href="https://zh.wikipedia.org/wiki/欧拉方法" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/欧拉方法</a> “欧拉法”)</li><li>linear equation</li><li>autonomous equation<ul><li>equilibrium values or rest points</li></ul></li><li>phase line</li><li>systems of equations<ul><li>autonomous</li></ul></li><li>phase planes<ul><li>trajectory</li></ul></li></ol><h1 id="十-12-10"><a href="#十-12-10" class="headerlink" title="十 ---12.10"></a>十 ---12.10</h1><h2 id="新概念"><a href="#新概念" class="headerlink" title="新概念"></a>新概念</h2><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>函数可导和连续 概念的理解</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;四-Vector-Algebra&quot;&gt;&lt;a href=&quot;#四-Vector-Algebra&quot; class=&quot;headerlink&quot; title=&quot;四 Vector  Algebra&quot;&gt;&lt;/a&gt;四 Vector  Algebra&lt;/h1&gt;&lt;h2 id=&quot;空间直线-空间平面&quot;&gt;&lt;a href=&quot;#空间直线-空间平面&quot; class=&quot;headerlink&quot; title=&quot;空间直线,空间平面&quot;&gt;&lt;/a&gt;空间直线,空间平面&lt;/h2&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://jianai0330.github.io/categories/2019/"/>
    
      <category term="KCL" scheme="https://jianai0330.github.io/categories/2019/KCL/"/>
    
      <category term="CMTE" scheme="https://jianai0330.github.io/categories/2019/KCL/CMTE/"/>
    
    
      <category term="空间向量" scheme="https://jianai0330.github.io/tags/%E7%A9%BA%E9%97%B4%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
</feed>
