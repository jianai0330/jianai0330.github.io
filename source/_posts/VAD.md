---
title: VAD
date: 2021-07-05 09:05:13
tag:
- 语音识别
categories:
- 2021
- Summer
- VAD
password: password
top: 300
---
##☺️🤣🍇日志
- 8.4 生成txt->调整txt格式到被帧数整除->可以分析    ---===---还需要调整阈值
- 

## VAD- -Paper
<!-- more -->
1. ### Kobe Japan的
    1. 概念上：VAD:话语激活检测
        1. 当用户的语音信号能量低于一定门限值时就认为是静默状态，也不发送语音分组。当检测到突发的活动声音时才生成语音信号，并加以传输。

        2. 从一段语音（纯净或带噪）信号中标识出语音片段与非语音片段
        3. ADC：模拟数字转换器，模拟信号转变为数字信号
        4. FPGA board： Field－Programmable Gate Array的缩写，即现场可编程门阵列。
        3. 第一步就是提取噪音信息。通常的思路是通过VAD函数得到非语音片段，而非语音片段可以认为是纯噪音片段。从而可以从纯噪音信号中提取出有用信息，例如进行傅里叶变换得到噪音频谱等，再进而做下一步处理。例如谱减法，维纳滤波。
        4. zero cross counter (ZCC)： 过零率，一帧语音时域信号穿过0（时间轴）的次数。 语音片段ZCC较小，非语音片段ZCC较大
        5. STE：short time energy：短时能量
        6. 我们通常使用麦克风进行音频录制的采样率为 16000Hz，一个采样点使用 16bit 来存储。
        7. ksps：单位，kilo Samples per Second ，即采样千次每秒，是转化速率的单位。
        8. dB：分贝
        9. S/N：信噪比（单位是分贝），信号与噪声的比例。设备的信噪比越高表明它产生的噪声越少。越高越好。
        8. d-flip flop：d触发器，两个稳定状态，即"0"和"1"
    2. 语音识别的特征提取
        1. (一篇知乎上的文章)[https://zhuanlan.zhihu.com/p/147386972] ：根据语音信号->预加重->分帧加窗->DFT->等等的流程来介绍

    3. 这篇文章：通过zero-crossing VAD algorithm判断speech或噪音，利用的原理就是把语音输入现转化为连续数字信号，再判断在某时刻该信号是否穿过x轴，如果这个input signal在该点的前一个峰值pass了设定的trigger line，那么它就是zero crossing，count相应+1.我们再根据某一段信号中zero crossing点出现的相对频率来判断这段信号到底是speech还是noise。用sum（用于记录zerocrossing数量的变量）/帧的长度来进行比较     （用中文做流程图）  。
        他们团队没有使用单片机，而是使用了FPGA芯片
        他们在陈述结果时，根据范围从-20----20dB的信噪比的变化，用了Correct，False accptance和False rejection
    4. 好处坏处，改进的
        -    ，，
        -    没有关注人说了什么什么，只要人发出声音就会被识别
    5. 我得想法和思考
    6. 不懂的地方
    7. 结合看的相关其他文章
2. ### 智能手表VADLite系统
    1. 这个团队研发的开源系统，是在智能手表上可以安装下载的app。
    2. 目的是结合他们以前有关于人体健康数据的智能产品，使得手表在用户呼叫的时候才会收集心率心跳等数据
    4. data preprocessing：他们收集了至少10个处于不同距离的不同的人对着手表讲话后的数据，一共3.5h。他们用了一个静默识别的算法来截取掉大部分安静的语音片段。 -----计算RMS（root mean square均方根），如果这个数值低于一个他们用离散点图确定下来的特定值，就标记为silence。  ---》然后用SVM来识别人声和噪声---》分成25ms一帧，提取12 MFCC features----》再用linear SVM来识别和分类。具体来说：
3. ### Tiny Voice
    1. ，，
    2. 。。。
    3. 选择存储器：
        1. 好处比较

    4. interface 功能和规则 + 具体的用汇编语言写的软件： 结合起来用两张图放在一起，一起来说。


    5. 我认为timer等一些想法或许我可以借鉴在我未来自己的设计中。它虽然很小，但并不是一个简单的系统。
    6. 不足：train的时候背景的噪音会对产生的template造成很大影响，从而影响recognize的效果。
4. ### pre ----for以上三paper ----结合以slide（稿件草稿版）
    可能耽误大家几分钟的时间，我将对我上个周阅读的三篇关于语音识别的文章向大家做一个简单的介绍和汇报。首先我会分别按照这三篇文章的大概脉络来说一下对这三种里面的算法啊应用啊我的理解，然后在最后总结的时候，我会横向比较一下这三个，说一下我的理解和困惑
    1. 感觉这三篇都没有着重讲算法的实现和理论的公式，所以对于我来说比较好理解。 我首先会简单介绍文章中所提到的它们的背景，目的等，我可能要简单说一下硬件部分，着重讲一下我所理解的，他们实现VAD的方法。最后我会比较和总结一下这三种应用，说一下自己的思考和一些困惑。
    1. 介绍第一篇论文：在一个智能通用传感器系统里，为了能够减少能耗，他们设计和应用了这个VAD模块。就是当vad没有识别到语音信号的时候，这个系统的其他电路都是没通电的。
        1. 。。。
        2. 我不熟悉画这种图所以引用了一张原文的图片    着重的是这两点     这个帧长根据文中的描述应该是256
        1. 不足：文章中也提到，相比于一些frequency domain algorithm ，我们的zero crossing算法作为基于时域的，在信噪比比较低的情况下准确率一般
            2. 然后我可能对于这两条trigger line的确定方法不是很懂 --结尾
    2. 。。
    3. 第二篇VADLite（手表）：
        1. 来自苏黎世联邦理工大学的开源项目
        2. 设计初衷是希望与他们之前的智能人体健康数据产品相结合，使得在用户呼唤手表时，能够相应的测量和记录血压血样心率等等数据
        3. 下面这个图简单描述了系统的框架，分为两个模块。他们用了pipeline。
        4. ，，，
        5. 在预处理过程中，计算RMS（root mean square均方根），如果这个数值低于一个临界值，就标记为silence。静默片段的这个阈值是根据所有声音片段的RMS生成的离散点图确认的。
        6. 再到特征提取：他们团队使用了梅尔频率倒谱系数   ----并没有详细讲mfcc的基础知识，我只是简单了解了一下原理。（一组声音数据，分成很多帧，每一帧经过快速傅立叶变换FFT获得相应的频谱，然后再经过梅尔滤波器获得梅尔频谱，然后在梅尔频谱上进行倒谱分析--取第2-13个系数）
        7. 在分类里，用了线性SVM。（一种监督学习的方法，我对SVM的理解就是篮球红球，棍子分开），
        8. 用了网格搜索来调参--（常用的找最优超参数的算法）
        9. 标准化：介绍的是减去均值再除以方差
    4. 。。。
    5. 第三篇呢是一个期刊上对于产品的介绍。
        1. ，，，
        2. 他这个处理器是没有数字电路转换器的，所以他用了一个集成电路板来把时域信号转化成单片机能够识别的信号
        3. tiny voice的语音识别运用的理论基础就是把声音信号分为两个不同频率范围的共振峰区
        3. high-pass filtered：高通滤波，过滤掉低频信号
        4. 硬件上用了这个只读存储器，在这里先略过。
        5. 对于
        6. 简略的flowchart：
            - recognize按下后的模式里。。。。。在没有阅读相似的源码的情况下，我觉得我还完全没有知其所以然
    6. 可能前面几页不够直观清晰，这一页我把他们放在一起，，
    7.
    6. 然后比较这三篇文章三种应用的话，我觉得相对于像tiny voice一样用不带ADC的处理器或者像FPGA这种半定制电路/逻辑门array，对于我这种初学者可能刚开始用一些比较好上手的单片机更好。
    7. 好像一些基本原理我都已经知其然了，但是具体的算法实现和理论基础（你比如说像MFCC和SVM）我还要加深理解才行，需要更多的阅读和实践
    8. 然后文章里具体描述的一些数据，采样频率等等我需要在自己的实践中慢慢来体会。

## stm32F750 🌟VAD项目✨
1. ### 初识
    1. 公司：ARM；内核：Cortex-M3内核的32位闪存微控制器
    2. 电压范围2--3.6v I/O电压容限为5V
    3. N8H6：
        - 8是`64k字节`的的闪存存储器
        - H：封装的类型：BGA（BGA封装： Ball Grid Array Package）
        - 6: -40--85摄氏度
6.30 ： stm32
周四7.1: 了解stm32 （I/O，串口）
7.5 周一：阅读资料
    2. stm32系统`时钟`控制： 3种不同时钟源
        1. HSE振荡器时钟：
            1. 高速外部时钟信号
                1. HSE外部`晶体`/陶瓷谐振器
                2. HSE用户`外部`时钟
        2. HSI振荡器时钟
            1. 由`内部`8MHz的RC振荡器产生，直接作为系统时钟信号
            2. 与HSE相比，不需要任何外部器件，启动时间短，但精度差。备用
        3. PLL时钟: 内部 倍频
            - 如使用usb，PLL必须被配置为输出48/72MHz时钟，用于提供48MHz的USBCLK时钟
        4. 1MHZ的时钟频率，则时钟周期为1us；若采用4MHZ的时钟频率，则时钟 周期为250us
            - 6MHz的话，就是1/6us，12M的晶振，它的时间周期就是1/12 us
    3. 中断系统：支持的中断84个（16个内核+68个外部）
    4. 固件函数库从：24个库（flash，lib，nvic中断，rcc时钟（Reset &  clock control），gpio管脚绝大部分程序都涉及）
    5. 软件配置：通过设置flash菜单下的选项，选择目标芯片和型号，flash和RAM的存储起始地址和大小，选择仿真调试工具，闪存空间等
    6. 模块化编程：
        1. 添加启动文件（cortexm3_marco.s和stm32f10x_vertor.s）
        2. 添加对应外设的固件函数库（stm32f10x_xxx.c）
        3. 添加中断服务程序模块（stm32f10x_it.c）
        4. 编写外设配置（初始化）模块代码
            1. 开时钟RCC
            2. 自身初始化
            3. 相关管脚配置（GPIO）
            4. 是否使用中断（NVIC）
            5. 编写main函数中的应用程序及其子程序（一定要将`#include stm32f10x_lib.h`文件包含在其中）
    7. NVIC（nested vector interrupt controller嵌套向量中断控制器）
        1. 控制异常，设置各个异常的优先等级并对异常进行处理
            - 所有异常都在处理器模式中处理 --handler mode
        2. 抢占 （产生嵌套，咬尾，晚到）
        3. NVIC支持优先级分组机制

    8. IO由软件配置--8种模式：
        1. 推挽输出：输出高，低电平，连接数字器件 两个三极管（参数相同），各负责正负半周的波形放大任务
        2. 等等
        3. IO配置常用的8个寄存器：
            1. MODER寄存器：GPIO端口模式控制寄存器 每两位配置一个IO口的I/O方向
            2. OTYPER寄存器：控制GPIO的`输出`类型  每一位配置一个I/O口的输出类型（推挽0/开漏1）
            3. OSPEEDR寄存器：GPIOs的输出速度 每两位
            4. ODR: 控制`输出`电平（高/低）
            5. BSRR: 复位
            6. IDR：读取GPIOx的输入数据
            7. 两个32位复用功能选择寄存器AFRH+AFRL
    9. 外设 的概念
        1. 还有外设的使能，失能，复位
            1. 使能 enable
        7.7未完待续
    10. 固件库与寄存器
        1. 固件库就是函数的集合（API），把寄存器操作封装起来
        2. ...
    11. stm32里有xx组I/O，每一组IO有16个IO口，每组IO有10个32位寄存器。每组IO其实就是一个GPIO端口
    12. 复用？？
        1. PA5为例， PA5支持的三种外设（SPI1、DAC、ADC）在同一时刻只能选择一种，选择的方法是开启相应外设的时钟，并使其它外设的时钟保持关闭状态。如果PA5被配置为复用功能，但是没有开启它支持的任何外设的时钟，它的输出是不确定的。


    13. 串口的通信（结合串口通信实验）
| 通信标准 ｜ 引脚说明 ｜ 通信方式 ｜ 通信方向 ｜
| :----: | :---: | :---: | :---: |
| UART(通用异步收发器)  | TXD（发送端）；RXD（接收端）；GND（公共地） | .. | 全双工 |
| SPI | SCK(同步时钟)；MISO；| 同步通信 | 全/半双工 |
            1. ![串行通讯和并行通讯](https://pic2.zhimg.com/80/v2-dc0f1343063ddcb1fdd1e89ffc9fd529_1440w.jpg)
            2. 全双工：同一时刻两个设备之间 同时 收发数据






2. ## 实验 源码 上手
    1. 跑马灯 HAL库 源码   ---`IO口输出`
        1. 7.6周二下午 成功 --结合开发手册，需要着重理解的是`GPIO`和`LED0（1）LED1（0）`(led.h文件里的IO输出电平取反操作)
        2. 初识了一个project的全过程 --注意有HARDWARE文件夹的创建，LED加入path等等基本过程
        3. LED亮灭：引脚输出高低电

    2. 按键输入  --- `IO口输入`
    3. 串口通信  --主要是串口中断接收--每次接收到一个字符后->进入`中断`服务函数来处理
        1. HAL库
            1. huart串口句柄（一个传递参数，是个指针）
            2. uart是什么的缩写？
            2. 串口MSP函数HAL_UART_MspInit --设置GPIO等MCU相关配置（因为HAL_UART_Init初始化与串口本身相关的参数【波特率停止位等】，MSP函数会在Init内部调用）
            2. HAL中定义了一个串口中断处理函数 HAL_UART_IRQHandler.
            3. HAL_UART_RECEIVE_IT，开启接受中断 ---把每次接收到的字符保存在缓存指针中
            4. 接收完成回调函数RxCpltCallback（huart）   ---这些函数的参数都是huart😹
            5. TDR ： 发送数据寄存器

        2. 源码中：
            1. usart.c中
                1. USART1->ISR&0x40 表示什么？
                2. u8是什么  --u8是unsigned char，u16是unsigned short，u32是unsigned long
    4. 定时器
    5. ADC：
        1. 板子里有3个ADC
        2. ADC的寄存器们：
            1. ADC_CR1  -- 存放转换结果
            2. ADC_CCR --ADC通用控制寄存器
            3. EOC在ADC_SR状态寄存器里
        3. P12（多功能端口）的ADC插针 与 核心板上的PA5相连接

`定时器 io 串口 adc`
采样频率 （定时器 1ms或者0.1ms）
adc 直流电源
单模块 集成调试

# sound sensor
## 对于ADC的疑问
    1. “外设复用：对于ADC和DAC，在GPIOX_MODER寄存器中将所需I/0配置为模拟通道。” 但是sensor提供的源码里用的是输入上拉模式
